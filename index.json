[{"categories":null,"content":"在据说最灵的佛前默念， 心中许下奇特的愿。 未果， 佛言这是渡我的考验。 沉湎，沦陷，深渊。 思来想去， 奋力向前， 大爱这风雨变幻。 我满心期盼， 是一道光线， 亦是一缕青烟。 一时潮涌， 终归平澜。 漫漫，偏安，坦然。 ","date":"2024-12-03","objectID":"/posts/2024-12-03%E6%B1%82%E4%BD%9B/:0:0","tags":null,"title":"求佛","uri":"/posts/2024-12-03%E6%B1%82%E4%BD%9B/"},{"categories":["历史"],"content":"阅读维基百科： 东周 春秋时期 战国时期 晋国 晋文公 ","date":"2024-12-01","objectID":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/:0:0","tags":["历史"],"title":"春秋时期的主要政治事件","uri":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/"},{"categories":["历史"],"content":"东周 *（前770年至前256年） 东周也是“春秋时代”的开始，因孔子修订《春秋》而得名 齐桓公、宋襄公、晋文公、秦穆公、楚庄王相继称霸，史称“春秋五霸” “周初千八百国，至春秋之初，仅存百二十四国。春秋诸国，吞并小弱，大抵以其国地为县。因灭国而特置县，因置县而特命官，封建之制遂渐变为郡县之制。” ","date":"2024-12-01","objectID":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/:1:0","tags":["历史"],"title":"春秋时期的主要政治事件","uri":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/"},{"categories":["历史"],"content":"主要历史事件 ","date":"2024-12-01","objectID":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/:2:0","tags":["历史"],"title":"春秋时期的主要政治事件","uri":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/"},{"categories":["历史"],"content":"周平王迁都 前771年，因周幽王宠信褒姒，废太子宜臼。宜臼逃至申国，其外公申侯联合曾侯、许文公及犬戎（外族）推翻周幽王，都城宗周被毁坏，后周平王即位，前770年周平王被迫将国都从镐京迁至成周（雒邑）。 申侯引犬戎攻入京师，害死女婿周幽王，以恢复外孙周平王的太子地位，拥立平王，使平王有弑父之嫌，因而使周天子在诸侯间的威望下降，其次各诸侯国势力逐渐强大，互相攻伐，故平王东迁后，周室渐渐衰落。周王室放弃了原本的关中地区（宗周），只有洛邑周边（成周）一小块王畿，人口则锐减，而且外族狄侵扰频密，导致周天子失去对其他诸侯国的控制，中原诸国亦难以自安。 ","date":"2024-12-01","objectID":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/:2:1","tags":["历史"],"title":"春秋时期的主要政治事件","uri":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/"},{"categories":["历史"],"content":"周郑交质 卿士郑庄公连打胜仗，势力愈强，渐不尊周王 周平王不敢得罪郑庄公，公元前720年，将王子狐送往郑国作为质子；而郑国公亦将子忽作为质子送往都城雒邑，史称“周郑交质” 历史意义 自平王东迁以来，周王权威早已实际崩溃。但王及诸侯都没有将此事捅破。而周郑交质，作为臣子的郑国和作为天子的周王以平等二国的姿态交换人质，作为可供观测的事件点而成为周王权威崩溃的标志。 东周“礼崩乐坏”的缩影，但各国没能力取代周天子，故尊王攘夷。 𦈡葛之战 周桓王十三年（前707年），周桓王率陈、蔡、卫等国军队讨伐郑国，郑庄公领兵抗拒，两军战于𦈡葛（今河南长葛北），郑庄公击败王师，箭中王肩。虽事后郑庄公派人慰问周桓王，可是此事令周王的地位严重下降，仅为名义上之天下共主。而小国为求存，亦不再依附王室，反而选择附和实力强大的诸侯。 ","date":"2024-12-01","objectID":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/:2:2","tags":["历史"],"title":"春秋时期的主要政治事件","uri":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/"},{"categories":["历史"],"content":"齐桓公称霸 前685年，齐国君主齐桓公继位，以管仲为相，实施变法，废除井田制度，按土地的肥瘠，确定赋税，设盐、铁官和铸钱，增加财政收入，寓兵于农，将基层行政组织和军事组织合为一体，增加了兵源和作战能力，迅速成为华夏各国中最富强的国家。然后就打起了“尊王攘夷”的口号，多次大会诸侯，帮助或干涉其他国家，抗击夷狄。 周惠王二十一年（前656年），齐桓公带领八个诸侯国的联军，陈兵“蛮夷”楚国边境，质询楚国为何不向周王室朝贡，迫使楚国签订召陵之盟，又于公元前651年举行葵丘会盟，成为春秋五霸之首。 ","date":"2024-12-01","objectID":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/:2:3","tags":["历史"],"title":"春秋时期的主要政治事件","uri":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/"},{"categories":["历史"],"content":"宋楚之争 周襄王九年（前643年），齐桓公重病，五子夺位，齐国内乱不止。冬十月七日，齐桓公饿死。公子昭奔宋。 周襄王十年（前642年），宋襄公率领卫国、曹国和邾国等四国人马打到齐国，齐人里应外合，把逃到宋国求援的公子昭拥立为齐孝公，襄公因此小有名气，想继承齐桓公的霸业。 楚国兴起，自称为王，消灭了其北方的几个小国之后将矛头指向中原。宋襄公试图效法齐桓公，以抵抗楚国进攻为名，再次大会诸侯以成为霸主，但宋国实力与威望都不足，战败，楚成王称雄一时。 评宋襄公：该以德服人时不好好做，面对敌人又举仁义大旗 评齐桓公：赫赫一世，如此结局，人生无常却有迹可循 ","date":"2024-12-01","objectID":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/:2:4","tags":["历史"],"title":"春秋时期的主要政治事件","uri":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/"},{"categories":["历史"],"content":"晋文公践土之盟 晋国，与周室同宗。晋献公时期晋国向四面扩张，领土和国力大增。 前636年，晋献公之子重耳在秦穆公派出的军队护送下继承晋国君位，是为晋文公。 传奇一生，流亡19年，经历狄、卫、齐、曹、宋、郑、楚、秦八国 改革政治，发展经济，整军经武，取信于民，安定王室，友好秦国（秦晋之好），在诸侯中威信很高。 周襄王二十年（前633年），楚军包围宋国都城商丘。次年初，晋文公率兵救宋，在城濮之战大败楚军，然后会盟于践土，成为中原霸主。 退避三舍 ","date":"2024-12-01","objectID":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/:2:5","tags":["历史"],"title":"春秋时期的主要政治事件","uri":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/"},{"categories":["历史"],"content":"秦穆公独霸西戎 晋文公死后，秦晋联盟被瓦解，秦穆公谋求向东方发展，被晋所阻。 秦晋几次战役，秦都惨败，终没法挑战晋在中原的地位，惟有转而向西发展 秦穆公任用由余,在公元前623年，吞并了20个戎狄部族，之后其余20多国也相继归附秦，独霸西戎。 终获得周天子承认 ","date":"2024-12-01","objectID":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/:2:6","tags":["历史"],"title":"春秋时期的主要政治事件","uri":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/"},{"categories":["历史"],"content":"楚庄王问鼎中原 城濮之战后，楚国向东发展，灭了许多小国，势力南到今云南，北达黄河。 楚庄王改革内政，平息暴乱，启用贤臣孙叔敖兴修水利，改革军制，国力更为强大，在攻克陆浑戎后，陈兵周郊，向周定王的使者询问象征国家政权的传国宝器 - 九鼎的大小轻重，意在灭周自立，此即“问鼎”的来源。 周定王十年（前597年），楚与晋会战于邲（邲之战），大胜晋国。前594年，楚围宋，宋告急于晋，晋不能救，宋遂与楚言和，尊楚。这时中原各国除晋、齐、鲁之外，尽尊楚庄王为霸主。 ","date":"2024-12-01","objectID":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/:2:7","tags":["历史"],"title":"春秋时期的主要政治事件","uri":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/"},{"categories":["历史"],"content":"晋楚大战与弭兵会盟 晋楚两大国势均力敌，谁都无法击垮对方，连年大战，给人民带来巨大的灾难，也引起中小国家的厌倦。 宋国两次出面斡旋，组织会盟，停止战争 ","date":"2024-12-01","objectID":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/:2:8","tags":["历史"],"title":"春秋时期的主要政治事件","uri":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/"},{"categories":["历史"],"content":"吴越雄霸东南 当中原诸侯争霸接近尾声时，地处江浙的吴、越开始发展。吴王阖闾重用孙武、伍子胥等人。 周敬王十四年（前506年），吴王以伍子胥为大将，统兵伐楚。 伍子胥为父兄报仇，掘楚平王陵墓，鞭尸三百。 周敬王二十六年（前494年），吴王夫差为父报仇，兴兵败越。勾践求和 吴王拒绝了伍子胥联齐灭越的建议，接受越国求和，转兵向北进击，大败齐军，成为小霸。 勾践卧薪尝胆，周元王三年（前473年）发动越灭吴之战，消灭吴国，夫差羞愤自杀。勾践北上与齐晋会盟于徐，成为最后一个霸主。 ","date":"2024-12-01","objectID":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/:2:9","tags":["历史"],"title":"春秋时期的主要政治事件","uri":"/posts/2024-12-01%E6%98%A5%E7%A7%8B%E6%97%B6%E6%9C%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E6%94%BF%E6%B2%BB%E4%BA%8B%E4%BB%B6/"},{"categories":["articles"],"content":"记录一下自己的想法。这里的重点并不是“打算”，希望这不是自欺欺人。 冯唐在抖音宣称，“如果只读一本书，我就选《资治通鉴》。” 也找到了 YouTube 链接： 冯唐讲《资治通鉴》01 发刊词：一生只读一部书，就读《资治通鉴》 - YouTube， 当前还在持续更新中。 冯唐：如果只读一本书，我就选《资治通鉴》（资治通鉴熊逸版第1辑）书评 这篇豆瓣书评有一点参考性，但是“屡经政争波折，司马光终于还是被排挤出了朝廷，在熙宁五年，他定居洛阳，做了一名无所事事的闲官。司马光把自家花园取名“独乐园”，绝口不谈政事，闭门著书，苦心孤诣近二十个，编写出了这套煌煌巨著《资治通鉴》。” 这描述很误导人啊，给人的感觉是完全放弃政治抱负，独自在那隐忍著书，其实不是。 资治通鉴 - 维基百科，自由的百科全书 从维基百科搜索的一些历史资料： 《资治通鉴》是司马光所主编的长篇编年体史书，共294卷，三百万字。 司马光编集此书，朝廷许他“自辟属官”，他邀请了刘攽、刘恕、范祖禹成为助手，这些人都是当时著名史家，可谓一时之选。 政治上，强硬的守旧派，历仕仁宗、英宗、神宗、哲宗四朝。 写作时间一共花了19年，从宋英宗治平二年（1065年）开始一直到宋神宗元丰七年（1084年）才完成。 治平三年（1066年）撰成战国迄秦的《通鉴》八卷上进宋英宗，英宗命设局续修，并供给费用，增补人员。宋神宗以其书“有鉴于往事，以资于治道”，赐书名《资治通鉴》，并亲为之序。 熙宁三年（1070年），自请离京，以端明殿学士的身份担任知军一职。次年退居洛阳，闲职，继续编撰《通鉴》，至元丰七年（1084年）成书。书成后，司马光官升为资政殿学士。（15 年闲职著书） 元丰五年秋天，司马光已罹患“语涩疾”（疑当中风）。 元丰七年十一月司马光《进通鉴表》“臣今骸骨癯瘁，目视昏近，齿牙无几，神识衰耗，目前所为，旋踵遗忘。臣之精力，尽于此书。” 元丰八年（1085年）宋哲宗即位，高太皇太后听政，召他入京主国政，次年，罢黜新党，尽废新法，割让大量土地百姓给西夏，所谓“元祐更化”。 元祐元年（1086年）六月，在司马光力主下，宋将此前从西夏攻取之地尽数还于西夏。司马光割地的理由是“如此则西人忽被德音，出于意外，虽禽兽木石，亦将感动，况其人类，岂得不鼓舞蹈，世世臣服者乎。”然而，西夏得地后并未停止攻击北宋，甚至在抄掠后还羞辱性的致书北宋称“欲取延州，终以恭顺，止取金明一砦，以示兵锋，亦不失臣子之节也。” 元祐元年九月初一日（1086年10月11日），司马光执政一年半，即与世长辞，享寿六十六岁。“京师人为之罢市往吊，鬻衣以致奠，巷哭以过车者，盖以千万数”，灵柩送往夏县时，“民哭公甚哀，如哭其私亲。四方来会葬者盖数万人”，“家家挂象，饭食必祝”。高太皇太后命葬之于高陵。 宋徽宗在位时，当时的新党掌权人蔡京把元祐年间反对将王安石新法的司马光等旧党309人，列为“元祐奸党”。 司马光的《资治通鉴》(通鉴)与司马迁的《史记》(太史公记)并列为中国史学的不朽巨著，所谓“史学两司马”。 趣事：冯唐说，“某某伟人《资治通鉴》一生读过17遍。实话讲，我不信。”《冯唐讲》正式上线 – 冯唐 维基百科上写的是毛泽东曾十七次批注过《资治通鉴》。原来他指的某人是毛泽东啊，不敢直呼其名，怕被怼。 自古士大夫追求“修身，齐家，治国，平天下。” 著书，修史，都是前路无望，“退而著书”。 司马迁《报任安书》有云：“盖文王拘而演《周易》；仲尼厄而作《春秋》；屈原放逐，乃赋《离骚》；左丘失明，厥有《国语》；孙子膑脚，《兵法》修列；不韦迁蜀，世传《吕览》；韩非囚秦，《说难》《孤愤》；《诗》三百篇，大底圣贤发愤之所为作也。此人皆意有所郁结，不得通其道，故述往事、思来者。乃如左丘无目，孙子断足，终不可用，退而论书策，以舒其愤，思垂空文以自见。” “以史为镜，可以知兴替。” 柏杨版资治通鉴 - 维基百科，自由的百科全书 ","date":"2024-11-30","objectID":"/posts/2024-11-30%E6%89%93%E7%AE%97%E6%8A%BD%E6%97%B6%E9%97%B4%E5%A5%BD%E5%A5%BD%E8%AF%BB%E8%AF%BB%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/:0:0","tags":["articles"],"title":"打算抽时间好好读读资治通鉴","uri":"/posts/2024-11-30%E6%89%93%E7%AE%97%E6%8A%BD%E6%97%B6%E9%97%B4%E5%A5%BD%E5%A5%BD%E8%AF%BB%E8%AF%BB%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/"},{"categories":["extracts"],"content":"耗子叔去年不幸离世，一个很了不起的程序员，声明自己至少45岁前不会出书，可生命却定格在了40岁。 今日再次拜读他的技术博客。Copy 一下他的一篇有意义的文章，防止后面酷壳网站没人维护，服务器资源自动释放后就什么也找不到了。 原文链接： 使用简单的逻辑方法进行独立思考 | 酷 壳 - CoolShell \u003c开始\u003e 这是一个非常复杂的世界，这个世界上有很多各式各样的观点和思维方式，作为一个程序员的我，也会有程序员的思维方式，程序员的思维方式更接近数学的思维方式，数学的思维方式让可以很容易地理清楚这个混乱的世界，其实，并不需要太复杂的数学逻辑，只需要使用一些简单的数学方法，就可以大幅提升自己的认识能力，所以，在这里，记录一篇我自己的思维方式，一方面给大家做个参考，另一方面也供更高阶的人给我进行指正。算是“开源我的思维方式”，开放不仅仅是为了输出，更是为了看看有没有更好的方式。 我的思维方式中，使用数学逻辑的方式进行思考，通常来说，我会使用五步思考的方式： 第一步：信息数据可考证。如果一个观点或是一个见解的数据是错误的，那么就会造成后面的观点全是错的，所以，首要的是要进行数据的查证或考证。一般来说，如果一篇文章的作者足够严谨的话，他的需要给他的数据建立相关的引用或是可以考证的方法方式。如果一篇文章中出现的是，“有关专家表明”、“美国科学家证明”、“经济学家指出”，但是没有任出处，也没有点明这个专家或是科学家的名字，或是，也没有说明或引用让读者可以自己去验证的方法。那么，其引用的话或是数据是无法考证的，如果是无法考证的，那么，这篇文章的水份就非常大了。一般来说，当我读到一篇文章中的东西没有可考证的来源或是方法时，通常来说，我就不会再读了，因为这篇文章的价值已经不大了，如果我关心这篇文章中的东西，我会改为自己去查找的方式，虽然变“重”了，但是很安全。（所以，像Wikipedia这样的网站是我经常去获得信息的地方，因为信息可以被考证是其基本价值观） 第二步：处理集合和其包含关系。这是一个非常简单的人人都会的数学逻辑。比如：哲学家是人，柏拉图是哲学家，所以，柏拉图是人。就是一个在包含关系下的推理。你不要小看这个简单的逻辑，其实很多人并不会很好的应用，相反，当感情支配了他们以后，他们会以点代面，以特例代替普遍性。比如，地图炮就是一种，他们看到了多个案例，他们就开始把这个案例上升上更大的范围，比如：河南人新疆人都是小偷，上海人都是小市民。日本人都是变态和反人类……等等。除了这些地图炮外，还有否定整个人的，比如一个人犯了个错或是性格上有缺陷，就会把整个人全盘否定掉，员工抢个月饼就上升到其价值观有问题……。在数学的逻辑包含中，超集的定义可以适用于子集，通过子集的特征可以对超集进行探索，但是没法定义超集。另外，集合的大小也是一个很重要的事，幸存者偏差会是一个很容易让人掉下去的陷阱，因为可能会有很大的样本集可能在你的视线盲区。 第三步：处理逻辑因果关系。所谓因果关系，其实就是分辨充分条件、必要条件和充分必要条件，然后处理其中的逻辑是否有关联性，而且有非常强的因果关系。没有能力分辨充分必要条件处理因果关系是很多人的硬伤。就像我在《努力就会成功》(Dison：这篇写的也很好。)中说的一样，“努力” 和 “成功”是否有因果关系？各种逻辑混淆、概念偷换、模糊因果、似是而非全是在这里。比如：掩耳盗铃、刻舟求剑就是因果关系混乱的表现。人们会经常地混淆两个看来一起发生，但是并没有关联在一起的事。因果关系是最容易被模糊和偷换的，比如：很多人都容易混淆“加班”就会有“产出”，混淆了“行动”就会有“结果”，混淆了“抵制”就会赢得“尊重”，混淆了“批评”等于“反对”……等等。除了这些以外，微信公众号里的很多时评文章，他们的文章中的结论和其论据是没有因果关系的，好多文章就是混淆、模糊、偷换……因果关系出问题的文章读多了是对大脑有损伤的，要尽量远离。 第四步：找到靠谱的基准线。就像我们写代码一样，我们都是会去找一些最佳实践或是业内标准，原因是因为，这样的东西都是经过长时间被这个世界上很多人Review过的，是值得依赖和靠谱的，他们会考虑到很多你没有考虑过的问题。所以，你也会看到很多时评都会找欧美发达国家的作参考的做法，因为毕竟人家的文化是相对比较文明、科学、开放和先进的。找到世界或是国际的通行标准，会更容易让人进步。比如：以开放包容加强沟通的心态，就会比封闭抵制敌对的心态要好得多得多，智者建桥，愚者建墙。当然，我们也开始发现，有一些事上，有利于自己的就对标，不利于自己的就不对标，而且，除了好的事，不好的事也在找欧美作对标，于是开始“多基准线”和“乱基准线”，这种方式需要我们小心分辨。 第五步：更为深入和高维的思考。如果一件事情只在表面上进行思考其实只是一种浅度思考，在Amazon，线上系统出现故障的时候，需要写一个Correction of Errors的报告，其中需要Ask 5 Whys（参看 Wikipedia 的 Five Whys 词条），这种思考方式可以让你不断追问到深层次的本质问题，会让你自己做大量的调查和研究，让你不会成为一个只会在表面上进行思考的简单动物。比如：当你看到有出乎你意料的事件发生时（比如负面的暴力事件），你需要问一下，为什么会发生，原因是什么？然后罗列尽可能全的原因，再不断地追问并拷证下去（这跟写程序一样，需要从正向案例和负向案例进行考虑分析，才可能写出健壮性很强的代码），我们才会得出一个比较健壮的答案或结构。 需要注意的是，在上述的这五种思维方式下，你的思考是不可能快得起来的，这是一个“慢思考”（注：如果读过《思考，快与慢》这本书的人就知道我在说什么），独立思考是需要使用大脑中的“慢系统”，慢系统是反人性的，所以，能真正做到独立思考的人很少。更多的人的“独立思考”其实只不过是毫无章法的乱思考罢了。 通过上述的这五点，我相信你是很容易识别或是分辨出哪些信息是靠谱的，哪些信息是很扯的，甚至会改善你自己的言论和思考。但是，请注意，这些方法并不能让你获得真理或是真相。但是这也够了，一个人如果拥有了能够分辨是非的能力，也是很不错的了。虽然不知道事实是什么，但是你也不会盲从和偏信，从而不会被人煽动，而成为幕后黑手的的一只“肉鸡”。 多说两句，下面是一些我个人的一些实践： 当新闻报道报道的不是客观事实，而是加入了很多观点，那么这篇新闻报道是不可信的。 对于评论性的文章，没有充足权威可信的论据时，不能完全相信。 不是当事人，不是见证人，还要装作自己是知情的……不知道这种人的自信怎么来的？ 信息不公开的，并有意屏蔽信息的，不能作为可信的信息源。 当出现大是或是大非的事时，一定要非常小心，这个世界不存在完全的美和完全的丑，这样的观点通常来说都是危险的，此时要多看看不同角度的报道和评论，要多收集一些信息，还要多问问为什么。 欢迎你告诉我一些你的实践和思维方式。 （全文完） ","date":"2024-11-30","objectID":"/posts/2024-11-30%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%BB%E8%BE%91%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%8B%AC%E7%AB%8B%E6%80%9D%E8%80%83/:0:0","tags":["extracts"],"title":"使用简单的逻辑方法进行独立思考","uri":"/posts/2024-11-30%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%BB%E8%BE%91%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%8B%AC%E7%AB%8B%E6%80%9D%E8%80%83/"},{"categories":["moods"],"content":" 曾国藩说：“事缓则圆，人缓则安，语迟则贵。” 当我快速描述一件事情，表达一个看法，我会出现很多口头禅，这真的有点糟糕。已经有两个人点到这一点了。 “但是”，“你听我说” 这都有急于自我证明和把问题推出去的味道。 “tmd”最近是出现的少了。 这是一个需要反思和改正的地方。这种问题不在于外部，而在内心。需要提前想清楚，谨言慎行。 By the way 被爱是奢侈的幸福…… ","date":"2024-11-29","objectID":"/posts/slow-in-speech/:0:0","tags":["moods"],"title":"语迟","uri":"/posts/slow-in-speech/"},{"categories":["tools"],"content":"调研 首先，在调研了好几个blog tools之后，还是hugo作为静态博客，优势巨大。主题方面，mogege已经很久没人维护了。 Hugo 主题推荐 对比了一些主题之后，主要在blowfish和LoveIt中挑选。 对比 blowfish LoveIt URL https://github.com/nunocoracao/blowfish https://github.com/dillonzq/LoveIt 中文文档 ✅ ✅ 特性 集成 Firebase、集成性能优化的 Youtube 卡片简码、支持 Fathom Analytics 和 Google Analytics 、多语言（更偏向国际化） 支持基于 APlayer 和 MetingJS 的内嵌音乐播放器、支持内嵌 Bilibili 视频、扩展 Markdown 语法、支持自定义样式的 shortcode、一键复制代码到剪贴板、支持更多的社交链接、网站分享和评论系统、桌面端/移动端 响应式布局、多语言 star 量 ","date":"2024-11-27","objectID":"/posts/2024-11-27%E5%B0%86hugo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E4%B8%BAloveit/:1:0","tags":["tools"],"title":"将Hugo博客主题修改为LoveIt","uri":"/posts/2024-11-27%E5%B0%86hugo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E4%B8%BAloveit/"},{"categories":["tools"],"content":"修改 各方面对比LoveIt更适合我一点,那么开始动手修改。（LoveIt比河豚名字也好听啊） ","date":"2024-11-27","objectID":"/posts/2024-11-27%E5%B0%86hugo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E4%B8%BAloveit/:2:0","tags":["tools"],"title":"将Hugo博客主题修改为LoveIt","uri":"/posts/2024-11-27%E5%B0%86hugo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E4%B8%BAloveit/"},{"categories":["tools"],"content":"首先是主题修改 主题文档 - 基本概念 直接把这个主题克隆到 themes 目录 git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt ","date":"2024-11-27","objectID":"/posts/2024-11-27%E5%B0%86hugo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E4%B8%BAloveit/:2:1","tags":["tools"],"title":"将Hugo博客主题修改为LoveIt","uri":"/posts/2024-11-27%E5%B0%86hugo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E4%B8%BAloveit/"},{"categories":["tools"],"content":"嵌入音乐 可以直接在md文件中加入shortcode,参考主题文档 - music Shortcode 这一点比mogege主题方便很多，不需要改源码。 shortcode中可以添加参数，例如autoplay ","date":"2024-11-27","objectID":"/posts/2024-11-27%E5%B0%86hugo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E4%B8%BAloveit/:2:2","tags":["tools"],"title":"将Hugo博客主题修改为LoveIt","uri":"/posts/2024-11-27%E5%B0%86hugo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E4%B8%BAloveit/"},{"categories":["tools"],"content":"扩展Shortcodes 参考 LoveIt主题扩展Shortcodes ","date":"2024-11-27","objectID":"/posts/2024-11-27%E5%B0%86hugo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E4%B8%BAloveit/:2:3","tags":["tools"],"title":"将Hugo博客主题修改为LoveIt","uri":"/posts/2024-11-27%E5%B0%86hugo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E4%B8%BAloveit/"},{"categories":["tools"],"content":"感受 事实说明LoveIt有点对不起它的名字，感觉一堆bug的样子。shortcode看起来还是很酷的，但是如果大量使用的话，如果再切换到别的主题就会犯难了。 网易云音乐本地调试时候不能及时加载。上了贼船，先试试，不行再切换回去。 ","date":"2024-11-27","objectID":"/posts/2024-11-27%E5%B0%86hugo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E4%B8%BAloveit/:3:0","tags":["tools"],"title":"将Hugo博客主题修改为LoveIt","uri":"/posts/2024-11-27%E5%B0%86hugo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E4%B8%BAloveit/"},{"categories":["moods"],"content":" 今晚去电影院看了这个电影，整理一下心情。 看的原因，被推荐，评分高，当然，让我说看就看的还得是有人陪同，否则可能只有《肖申克的救赎》这种级别的电影，会真的吸引我一个人冲进电影院。 晚上七点半看的，很多细节记不清了，凭回忆写点自己的感受。电影英文名《Her Story》直观很多，三个女主的故事，王铁梅(宋佳 饰)，她女儿王茉莉，恋爱脑的邻居小叶。相比之下，还是更喜欢中文名，这让我不禁思考到底什么是好东西，电影会怎样表达这个主题。 首先，从铁梅的前夫的行为来看，虽然有一些雄竞和迫切证明自己的成分，但他搞笑的“预约好了结扎“，以及后来掏出手机，不相信小马说的看过铁梅所有发表的东西，他对小孩的态度，几个细节看出他还是爱王铁梅的；他真心悔过，但正如他所表述的，“凭一己之力毁灭了她对男人的所有幻想”，伤她太深，回不到过去了，于是只能克制与成全。没说具体啥事，应该也是个王八蛋吧。 小叶的男朋友小胡，当下很多男人的共性，非常真实，除了渣，其他的好像也没啥毛病。 小马不是自己喜欢的一类人，真拧巴憋屈啊，不做点评。 果然男人确实没一个好东西。 铁梅是一个坚强独立的当代女性形象，但我觉得她的内心其实非常懦弱。她会自责自己对女儿内心的忽视，会很努力的管顾小孩的教育，但其实自己处理的并不好。在事业上，她坚定的表达自己的立场，被网暴后会说但是关注量翻倍了显得自己内心强大，却会在晚上盯着手机屏幕独自受伤。很久没工作没钱了，不得不在职场低头，但从开头跟女儿说现在住的房子很好，说了好几次的她买单，也是一个逞强的人。从开始的直播不敢露脸，到后来的放开叫卖带货，也是一种被逼迫的坚强的改变。没大搞清楚她的好东西是啥。并不是我喜欢的女人形象，太浓了，也挺E的。 小叶原生家庭的缺爱，让她更容易恋爱脑。不光是在跟男朋友小胡相处，还是跟其他人相处，她擅长撒谎，但更容易委屈自己讨好别人。她失眠吃大量安眠药，从其他人的表述来看，我认为更多的还是演唱不被认可导致，这是生存压力，其他的没那么重要，周边人这个时候的反应也体现了人性的善。她跟铁梅后来的对话，让我觉得她更清醒，能更坦然面对生活的不如意。 性对女人是不是好东西，我觉得电影给的回答有点含糊。最终铁梅对小马的态度，小叶对小胡的态度区别很大。每个人有自己的选择。 小茉莉是我印象最深的角色，她是幸福的。当遇到”我不再幻想“，”我很小时候去过巴黎“的困劲，有替她操心的妈，“朋友”小叶，乐队的资源，老师的关照，所有的爱让她没有封闭自我，从小就能勇敢坦诚的表达自己的需求，这是我很羡慕的。几篇高分作文，都是直击心灵，真诚且让人感动。原本以为自己喜欢打鼓，体验了架子鼓，然后明白自己不喜欢这个，更喜欢当一个听众听音乐演奏。人能知道自己内心的需求，这是好东西。既然我羡慕这个，我想要找补，那么于我而言，这种越是缺失，越是好东西。 有两个画面比较触到我内心。一是，茉莉带着耳机听声音，各种“泥石流、下大暴雨、河马吃饭”的猜测，但其实那些声音就来自日常生活，这是忙碌的人们不会观察到的。另一个画面是，茉莉被特别邀请参加演唱会，整首演奏的第一声是从架子鼓发起，第一声的那一刻，是一种心理突破。 好东西是啥？就如结尾演唱会里唱的那样，像个孩子一样，保持一份纯真，体验生活的美好。或许这就是好东西。 电影里有一段话，好像意思是说，人需要勇敢的表达自我，虽然会有人嘲笑和讽刺，但你迟早要面对社会的，让自己的声音被听到是一件好事。不知道是否认同。正好今天思考关于博客的问题。网上看到好几种声音，有觉得当下的博客已经发展到纯属自娱自乐的，有为了重建自己的表达欲的，有为了结识志同道合的人的，当然也有不会摆上台面来讲，纯功利性装逼或者展示自己来给求职加分的。看到某位博主的一句话，““达人须悦己”，写作（尤其是个人博客写作）不应该是一个目的性很强的事，而应该是一个自我记录、自我发现、自我探索与自我表达的过程。”很满意这个表述。 最后回到电影，整体来说，这部电影让人感动，没有特别强的共鸣，但真的挺不错。值得一看，不会二刷。 \u003c完\u003e ","date":"2024-11-24","objectID":"/posts/movie-her-story/:0:0","tags":["moods"],"title":"电影《好东西》观后感","uri":"/posts/movie-her-story/"},{"categories":["articles"],"content":"未 选 择 的 路 —— 罗伯特·弗罗斯特 黄色的树林里分出两条路， 可惜我不能同时去涉足， 我在那路口久久伫立， 我向着一条路极目望去， 直到它消失在丛林深处。 但我却选了另外一条路， 它荒草萋萋，十分幽寂， 显得更诱人、更美丽， 虽然在这两条小路上， 都很少留下旅人的足迹， 虽然那天清晨落叶满地， 两条路都未经脚印污染。 呵，留下一条路等改日再见！ 但我知道路径延绵无尽头， 恐怕我难以再回返。 也许多少年后在某个地方， 我将轻声叹息把往事回顾， 一片树林里分出两条路， 而我选了人迹更少的一条， 从此决定了我一生的道路。 ","date":"2024-11-23","objectID":"/posts/the-road-not-taken/:0:1","tags":["articles"],"title":"The Road Not Taken","uri":"/posts/the-road-not-taken/"},{"categories":["articles"],"content":"The Road Not Taken —— ROBERT FROST Two roads diverged in a yellow wood, And sorry I could not travel both And be one traveler, long I stood And looked down one as far as I could To where it bent in the undergrowth; Then took the other, as just as fair, And having perhaps the better claim, Because it was grassy and wanted wear; Though as for that the passing there Had worn them really about the same, And both that morning equally lay In leaves no step had trodden black. Oh, I kept the first for another day! Yet knowing how way leads on to way, I doubted if I should ever come back. I shall be telling this with a sigh Somewhere ages and ages hence: Two roads diverged in a wood, and I- I took the one less traveled by, And that has made all the difference. ","date":"2024-11-23","objectID":"/posts/the-road-not-taken/:0:2","tags":["articles"],"title":"The Road Not Taken","uri":"/posts/the-road-not-taken/"},{"categories":["articles"],"content":"感受 “Two roads diverged in a yellow wood, And sorry I could not travel both.” 诗人最终的选择是took the one less traveled by，并认为这对他至关重要。这真的很需要魄力，需要勇气。 不得不承认自己做不到，认知局限，但这也没什么，不是吗？我总能尝试做出在当下认知里正确的决定，即使错了，体验而已。 罗翔老师说：“人生其实没什么好后悔的，很多事就算真的能重来一遍，以自己当时的心智和阅历，很可能还是会做出同样的选择。只不过我们总是习惯，去美化那条没有选择的路。” 认同。 “巷子里的猫很自由，却没有归宿；围墙里的狗有归宿，终身都得低头。”不喜欢这种洗脑鸡汤，这里是有其他解的，当你强大了，自由，归宿，都会有，也不用低头。 人生行之至此，虽有遗憾，当下已然不差。我需要相信，所有的遗憾有一天会以另一种方式圆满。月有阴晴圆缺，但是当一切归于沉寂，月的本质还是圆的。 为自己而活。我已经努力了（抱抱自己），但可以更努力一点（fighting）。 ","date":"2024-11-23","objectID":"/posts/the-road-not-taken/:0:3","tags":["articles"],"title":"The Road Not Taken","uri":"/posts/the-road-not-taken/"},{"categories":["articles"],"content":"相关链接 https://www.douban.com/group/topic/2322589 https://www.ted.com/talks/robert_frost_the_road_not_taken?language=en\u0026subtitle=en 关于作者：有点厉害的 https://en.wikipedia.org/wiki/Robert_Frost (维基百科英文版内容更详细啊) ","date":"2024-11-23","objectID":"/posts/the-road-not-taken/:0:4","tags":["articles"],"title":"The Road Not Taken","uri":"/posts/the-road-not-taken/"},{"categories":["extracts"],"content":" 最近看到一篇文章，觉得说的有道理，copy到这里了，什么时候回头再反思下。 原文地址： https://zhuanlan.zhihu.com/p/442594160 “没有人可以回到过去重新开始，但每个人都可以从现在开始创造全新的未来。”——玛丽亚·罗宾逊（Maria Robinson） 1）开始与合适的人共度时光 什么是合适的人呢？ 合适的人，他们爱你并欣赏你，鼓励你以健康而积极的方式改善自己。 他们是使你更加积极向上的人，他们不仅拥抱你现在的身份，而且无条件地拥抱和支持你真正想成为的人。 2）开始直面问题 定义你的不是你的问题，而是你如何对它们做出反应并从中汲取智慧。 除非你采取行动和措施，否则问题不会消失。 尽你所能，去做自己可以做的一切。 也许问题很难，但是你只要朝着正确的方向一步步迈进，就会发现事情虽然艰难但也没那么可怕。 3）开始对一切诚实 对正确的事以及需要改变的事要诚实。 对要实现的目标和成为谁要诚实。 永远诚实对待生活的各个方面，因为这个世界从来不会以个人的意志为转移。 探索自身，寻找真相，以便你真正地了解自己。 当你持续地真诚地直面自己和这个现实的世界，你将对现在的处境会有更好的了解。并且可以更好地识别自己真正想去的地方以及如何到达那里。 4）开始将自己的幸福放在首位 你自己的需求很重要。 如果你不注重自己的需求，长此以往，你其实是在压抑自己的欲望。 请记住，照顾好自己需求的同时也可以照顾好周围人的需求，这是可能的。 一旦自身的需求被满足了，你将更有能力帮助最需要你的人。 所以，你可以开始思考，自己真正的需求是什么，然后好好去满足自己内心所求。 5）真正地开始做自己 试图成为别人只会浪费你的时间。 做你自己，拥抱内心深处那个有想法，有优势，有天赋，和其他人完全不同的自己。 最重要的是，对自己忠诚，要相信你是带着使命来过完这一生的。 如果暂时不能全力以赴，那就先让自己摆脱困境。 按照自己真实的意愿过一生，才会不枉此生。 6）开始活在当下 当下是一个奇迹，当下是你可以做出行动的唯一时刻，所以当下就是生活。 因此，不要再想将来会发生什么，不要再沉迷于过去发生或未发生的事情。 你要开始学会身处当下，了解自己当下的位置，当下的感受，当下的境遇，然后全然地去体验正在发生的一切。 如此，你才可以做到曾国藩所说的「既往不恋，当下不杂，未来不迎」。 7）开始珍惜错误带给你的教训 犯错没什么大不了，它们本来就是进步的垫脚石。 如果你总是不停地失败，那只能说明你没有拼尽全力，也没有好好吸取教训。 冒险，试错，跌倒，然后站起来继续尝试，在这个过程中，你不需要恐惧犯错。 相反，你要意识到自己可以从错误中获得经验，推动自己成长进步。 真正伟大的成就，都出现在漫长的失败之路的尽头，而你所担心的错误，往往正是你通往成功之路的钥匙。 8）己所不欲，勿施于人 时常审视自己说出去的话，做出来的事。 然后，反过来思考，如果别人对你说那样的话，做那样的事，你会喜欢吗？ 请用你希望别人对待自己的方式来对待别人。 9）开始享受已经拥有的东西 我们许多人的问题是，欲望太多，没有止境。 我们总以为自己只要拥有了一样东西之后，就会快乐。 可是，当我们真正得到了之后，我们很快又渴望着拥有新的东西。 很多人花费一生致力于获得新的人事物，却从来不去真正享受自己现在已经拥有的东西。 因此，每天早晨，当你第一次醒来时，请保持安静，想一想现在自己已经拥有的一切，并感谢它们出现在你生活里。 10）开始创造自己的幸福 如果你在等别人让你开心，那你大部分时候都开心不起来。 对你的现状感到满意，并积极地迈向明天的旅程，这是你可以做的选择。 如果你在已经拥有的人事物中去发掘幸福，那你最终会找到它。 11）开始给你的梦想一个机会 生活中，机会很少，很多时候我们都是在冒险。 即使遇到一个机会，你也永远无法百分百地确定它会给你带来你想要的，但你可以百分之百地确定什么都不做是肯定不行的。 大多数时候，你只需要去做就可以了，不管结果如何，它总是以它该呈现的方式结束。 最终，你要么成功，要么学习到了一些新东西。 这始终是一个双赢的结果。 12）开始相信你可以做好下一步 做很多事情都需要勇气。 有时候目标很大，但是你必须要相信自己准备好了迈出下一步，即使这一步非常小。 只有你开始相信自己能够做好下一步，你才能把握机会，迎接挑战。 13）出于正确的原因，去建立新的关系 当与他人建立关系时，你要考虑的是他是否诚实，是否靠谱，是否与你有同样的价值观。 选择你引以为傲，你欣赏，愿意向你展示爱和尊重的人做朋友。 注意人们的所作所为，要看清楚一个人，不要看他怎么说，而要看他怎么做。 14）开始给新朋友一个机会 这个世界一直都在变化，你也是在不停地成长。 所以你不可能永远都和同样的一群人一直在一起，随着某些关系的淡化，其他关系也会出现。 当你自然地放弃不再起作用的旧关系时，新关系的可能性才有机会来到你面前。 准备好学习，准备好成长，准备好挑战，并准备好与可能永远改变你生活的新的人会面。 15）开始与过去的自己竞争 懂得欣赏他人，向他人学习，但知道与他人竞争是浪费时间。 你只能和一个人竞争，那就是你自己，所以你要努力做到比过去的自己更好。 16）开始为他人的胜利欢呼 开始注意到你喜欢别人所做的事情，并告诉他们。 对周围的人表示赞赏，这会给你带来更美好的人际关系，也给自己带来了心理上的认同感。 因此，为那些正在进步的人感到高兴，为他们的胜利加油，并由衷地祝福他们。 当你为自己欣赏的人事物感到开心，其实你就把自己和他们调成了同频。 而最终，你也会渐渐获得别人的赞赏和祝福。 17）在困难下，你有选择一己态度的自由 遇到困难时，你会感到沮丧，难过。 这时候，请深呼吸一下，你始终有选择面对困难的心态。 扪心自问，在这些困难时期，除了自怨自艾，你还可以有什么样更积极的选择，你还可以采取什么样更积极的行动。 如果你总是可以从所谓的坏事中看到好的一面，你就总是可以从困境中发现生活的意义。 从困境中汲取力量，才会让你变得越强大。 18）开始原谅自己和他人 我们有时候会被自己或他人的行为所伤害。 尽管大部分人都会经历这样的痛苦，但有时候这种痛苦持续的时间会很久。 我们一遍遍地舔舐伤口，却从来没想过放手。 宽恕是永久解决这类痛苦的良药，这并不意味着你正在擦除过去或忘记发生了什么。 它意味着你要摆脱怨恨和痛苦，选择从人事物中汲取教训并继续生活。 19）开始帮助你周围的人 如果在某件事情上，你知道更好的方法，请帮助别人。 你对他人的帮助越多，他们对你的帮助就越多。 爱和善良会产生爱和善良，这是一个良性循环。 20）开始聆听自己内心的声音 你可以与最亲近的人讨论你的想法，但要给自己足够的空间以遵循自己的内心。 做真实的自己，做你心中正确的事。 21）开始注意自己的压力，并短暂休息一下 慢一点，深呼吸。 允许自己暂停，重新思考前进的方向。 当你很忙时，短暂的休息可以使你精神焕发并提高工作效率。 这些短暂的闲暇时光将帮助你恢复精力并反思自己最近的行动，从而确保它们符合你更大的目标。 22）开始注意到生活里的点滴美好 不必等待大事发生时才感受到美好，比如结婚生子，升职加薪，一夜暴富。 其实你可以从每天都会发生的小事中找到幸福感。 小事情包括在清晨安静地喝杯咖啡，给自己做一次早餐，跟他人分享自己喜欢的东西，等等。 每天注意这些小小的乐趣，会大大改善你的生活质量。 23）当事情还不完美时，就开始接受 请记住，「完美」是生活的敌人。 对于想要自我改善和改变世界的人来说，最大的挑战之一就是学会接受现状。 有时候，最好是接受并欣赏当下世界的现状，而不是试图使一切和所有人都符合你自己的完美期待。 你要过的不是完美的生活，而要在事物不完美时学会去爱和珍惜它们。 24）每天开始朝着目标努力 不积跬步，无以至千里。 无论你的目标多远大，你都要每天开始采取小而合乎逻辑的步骤来实现它。 工作越努力，你就会越幸运。 尽管我们许多人在生活中的某个时刻决定要追求内心之渴求，但实际上只有极少数人真正地为之努力。 而「努力」，是指始终致力于最终结果。 25）开始对自己的感受更加开放 如果你受到了伤害，请给自己提供必要的空间和时间来疗伤。 但同时，也要要保持开放，与最亲近的人交谈，告诉他们你的真实感受。 简单地将事情从你烦闷的胸口带到与他人的交流中，是你再次感觉良好的第一步。 26）开始为自己的人生负责 看清楚自己的选择和错误，并愿意采取必要的步骤来改进它们。 你要么为自己的生活负责，要么其他人会为你负责。 当你让他们这样做时，你的人生就不再为自己所掌控，而是受制于他人。 每个人面前都有一堆障碍，但是你必须对自己的人生负责，并克服这些障碍，你应该成为那个唯一直接控制人生结局的人。 27）开始积极培养你最重要的关系 只需简单地告诉那些重要的人他们对你的意义，就可以给你的生活以及你所爱的人的生活带来真实真诚的喜悦。 你不可能对所有人一视同仁，只有少数人值得你投入时间和精力。 确定那些于你而言非常重要的人，然后在他们身上付出真心，时间和金钱。 请记住，你不需要很多朋友，只需要确定自己有几个真正重要的朋友即可。 28）开始专注于你可以控制的事情 你无法改变所有事情，但却可以随时改变某些事情。 在无法控制的事情上浪费时间，这最终会让你的生活陷入痛苦和停滞。 你应该将精力投入到可以控制的事情上，并立即采取行动。 有勇气去改变那些可以改变的事，有度量去接受那些不能改变的事，并且有智慧去区别以上两类事情。 29）开始注意自己的财务状况 尽管金钱不是万能的，但是没有钱也是万万不能的。 记得黎巴嫩诗人纪伯伦说过这样","date":"2024-11-20","objectID":"/posts/make-living-more-pleasant/:0:0","tags":["extracts"],"title":"让人越活越愉悦的30件小事","uri":"/posts/make-living-more-pleasant/"},{"categories":null,"content":" locate:杭州,天津 a coder，tech stack: Java-based Hobbies:Reading, Music, Travelling INFJ address: https://lovedison.cn 小人物，不足挂齿，但对某些人很重要。写博客的目的：记录当下的心情和学习成长的过程，练习表达能力并作为一种发泄，以后视情况重新整理移作他用。 ","date":"2024-11-20","objectID":"/about-me/:0:0","tags":null,"title":"About me","uri":"/about-me/"},{"categories":null,"content":"Thank you for coming into my world. ","date":"2024-11-20","objectID":"/about-me/:0:1","tags":null,"title":"About me","uri":"/about-me/"},{"categories":["moods"],"content":" 我有罪 人必须对自己诚实 我总是浪费了很多的时间 如果我有遗憾，那是我自己的问题 我不得不承认我过的有点舒服，良心不安 ","date":"2024-11-18","objectID":"/posts/start-my-blog/:0:0","tags":["moods"],"title":"还是写博客吧","uri":"/posts/start-my-blog/"},{"categories":["java"],"content":"按上锁方式划分 隐式锁：synchronized Java的关键字，是Java提供的同步机制 不需要显式的执行加锁和解锁过程 显式锁：JUC包中提供的锁 JUC中提供的锁，加锁和解锁的方法都是显式的 ","date":"2023-05-16","objectID":"/posts/java-concurrent-programming-lock/:1:0","tags":["java"],"title":"Java并发编程——锁分类","uri":"/posts/java-concurrent-programming-lock/"},{"categories":["java"],"content":"按特性划分 乐观锁/悲观锁 按照线程在使用共享资源时，要不要锁住同步资源 悲观锁 在获取数据的时候会先加锁 实现：JUC的锁、synchronized 乐观锁 在获取数据的时候不会加锁 在更新数据的时候会判断数据是否被其他线程修改过 实现：CAS算法、JPA提供的@Version注解、关系型数据库的版本号机制 可重入锁/不可重入锁 按照同一个线程是否可以重复获取同一把锁 可重入锁 同一个线程可以重复获取同一把锁 实现：synchronized、ReentrantLock 不可重入锁 重复获取会发生死锁 实现：ReentrantReadWriteLock.WriteLock 一般来说，应该尽量避免使用不可重入锁，除非确实有必要使用它来解决某些特殊问题 简化实现：在某些场景下，使用不可重入锁可以简化代码实现，因为不需要考虑同一线程多次获取锁的问题 限制资源访问：不可重入锁可以限制某些共享资源的访问，从而保证资源的独占性和线程安全性 防止死锁：不可重入锁可以防止同一线程出现死锁的情况 提高公平性：不可重入锁可以提高锁的公平性，因为同一线程无法多次获取锁，其他线程可以更容易地获得锁 公平锁/非公平锁 按照多个线程竞争同一锁时需不需要排队，能不能插队划分 公平锁 多个线程按照申请锁的顺序来获得锁 实现：new ReentrantLock(true) 非公平锁 不是按照申请锁的顺序，允许“插队” 实现：new ReentrantLock(false)，synchronized 非公平锁的性能一般会比公平锁的性能好，因为非公平锁减少了线程切换的次数 非公平锁的优势在于吞吐量比公平锁大 独享锁/共享锁 按照多个线程能不能同时共享同一个锁 独享锁（排他锁）（写锁） 一次只能有一个线程获取到锁 实现：synchronized、ReentrantLock 共享锁（读锁） 一次可以有多个线程获取到锁 实现：ReentrantReadWriteLock.ReadLock 读锁可保证在读多写少的场景中，提高并发读的性能，增加程序的吞吐量 ","date":"2023-05-16","objectID":"/posts/java-concurrent-programming-lock/:2:0","tags":["java"],"title":"Java并发编程——锁分类","uri":"/posts/java-concurrent-programming-lock/"},{"categories":["java"],"content":"其他常见的锁 自旋锁 获取锁失败时，线程不会阻塞而是循环尝试获得锁，直至获得锁成功。 实现：CAS，举例：AtomicInteger#getAndIncrement() 分段锁 实现：ConcurrentHashMap 可以理解为对独占锁的性能优化 无锁/偏向锁/轻量级锁/重量级锁 是synchronized独有的四种状态 不可降级，只能升级 ","date":"2023-05-16","objectID":"/posts/java-concurrent-programming-lock/:3:0","tags":["java"],"title":"Java并发编程——锁分类","uri":"/posts/java-concurrent-programming-lock/"},{"categories":["java"],"content":"Java已经提供了synchronized，为什么还要使用JUC的锁呢？ synchronized同步锁的线程阻塞，存在有两个致命的缺陷：无法控制阻塞时长；阻塞不可中 断。 假如占有锁的线程被长时间阻塞（IO阻塞，sleep方法，join方法 等），由于线程在阻塞时没有释放锁，如果其他线程尝试获取锁，就会被阻塞只能一直等待下去， 甚至会发生死锁，这样就会造成大量线程的堆积，严重的影响服务器的性能。 JUC的锁可以解决这两个缺陷： tryLock(long time, TimeUnit unit) lockInterruptibly() 读多写少的场景，需要共享锁提高性能 JUC的ReentrantReadWriteLock.ReadLock ","date":"2023-05-16","objectID":"/posts/java-concurrent-programming-lock/:4:0","tags":["java"],"title":"Java并发编程——锁分类","uri":"/posts/java-concurrent-programming-lock/"},{"categories":["java"],"content":"CAS是什么？ compare and swap 本质是一条CPU的原子指令，可以保证共享变量修改的原子性。 执行函数：CAS(V,E,N) 当且仅当内存地址V中的值等于 预期值E 时，将内存V中的值改为N，否则会进行自旋操作（一般情况 下），即不断的重试。 ","date":"2023-05-16","objectID":"/posts/java-concurrent-programming-cas/:1:0","tags":["java"],"title":"Java并发编程——CAS","uri":"/posts/java-concurrent-programming-cas/"},{"categories":["java"],"content":"Java中对CAS的实现 Java不能像C/C++那样直接操作内存区域，需要通过本地方法(native方法)来访问。JAVA中的CAS操作都 是通过sun包下Unsafe类实（sun.misc.Unsafe），而Unsafe类中的方法都是native方法。 //offset：内存偏移量，offset 为o对象所属类中，某个属性在类中的内存地址偏移量 public final native boolean compareAndSwapInt(Object o,long offset,int expected,int x); compareAndSwapInt在看openJDK8的源码中位置： openjdk8/hotspot/src/share/vm/prims/unsafe.cpp ","date":"2023-05-16","objectID":"/posts/java-concurrent-programming-cas/:2:0","tags":["java"],"title":"Java并发编程——CAS","uri":"/posts/java-concurrent-programming-cas/"},{"categories":["java"],"content":"CAS缺陷 自旋开销（循环时间太长） 原子类AtomicInteger#getAndIncrement()的方法 只能保证一个共享变量的原子操作 ABA问题 如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但 是实质上它已经发生了改变，这就是所谓的ABA问题 解决方案：加版本号（类似于乐观锁）。即 在每个变量绑定一个版本号，每次改变时加1，即A —\u003e B —\u003e A，变成1A —\u003e 2B —\u003e 3A。 例如为了消除原子类AtomicInteger ar = new AtomicInteger(100);的ABA问题， 可以改用AtomicStampedReference\u003cInteger\u003e asr = new AtomicStampedReference\u003c\u003e(100, 1); ","date":"2023-05-16","objectID":"/posts/java-concurrent-programming-cas/:3:0","tags":["java"],"title":"Java并发编程——CAS","uri":"/posts/java-concurrent-programming-cas/"},{"categories":["java"],"content":"原子变量类 java.util.concurrent.atomic包 用法简单、性能高效、线程安全地更新一个变量的方式 可以解决volatile原子性操作变量的问题 Atomic包里的类基本都是使用Unsafe实现的包装类 ","date":"2023-05-16","objectID":"/posts/java-concurrent-programming-cas/:4:0","tags":["java"],"title":"Java并发编程——CAS","uri":"/posts/java-concurrent-programming-cas/"},{"categories":["java"],"content":"Atomic常用类 基本类型 AtomicInteger AtomicLong AtomicBoolean 引用类型 AtomicReference AtomicStampedReference AtomicMarkableReference 数组类型 AtomicIntegerArray AtomicLongArray AtomicReferenceArray 对象的属性修改类型 AtomicIntegerFieldUpdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater ","date":"2023-05-16","objectID":"/posts/java-concurrent-programming-cas/:4:1","tags":["java"],"title":"Java并发编程——CAS","uri":"/posts/java-concurrent-programming-cas/"},{"categories":["java"],"content":"AtomicInteger主要API 1 get()：获取当前值 getAndAdd(int delta)：获取当前值，并加上预期的值 getAndSet(int newValue)：获取当前值，并设置新值 getAndIncrement()：获取当前值，并自增 getAndDecrement()：获取当前值，并自减 2 addAndGet(int delta)：加上预期的值，返回增加后的数据 incrementAndGet()：增加1，返回增加后的值 decrementAndGet()：减少1，返回减少后的值 lazySet(int newValue)：仅仅当get时才会set 3 compareAndSet(int expect, int update)：尝试新增后对比，若增加成功则返回true否则返回false demo public class Demo { public static void main(String[] args) throws InterruptedException { VolatileDemo demo = new VolatileDemo(); for (int i = 0; i \u003c 2; i++) { Thread t = new Thread(demo); t.start(); } Thread.sleep(1000); System.out.println(\"count = \" + demo.count); } static class VolatileDemo implements Runnable { public AtomicInteger count = new AtomicInteger(0); public void run() { addCount(); } public void addCount() { for (int i = 0; i \u003c 10000; i++) { count.incrementAndGet(); } } } } ","date":"2023-05-16","objectID":"/posts/java-concurrent-programming-cas/:4:2","tags":["java"],"title":"Java并发编程——CAS","uri":"/posts/java-concurrent-programming-cas/"},{"categories":["java"],"content":"定义 UML即统一建模语言（Unified Modeling Language） 这种统一建模语言是由图表组成的。 常用的有：序列图、类图、状态图、对象图、组件图和部署图等 ","date":"2023-05-15","objectID":"/posts/uml-class-diagram/:1:0","tags":["java"],"title":"UML类图","uri":"/posts/uml-class-diagram/"},{"categories":["java"],"content":"类之间的关系 ","date":"2023-05-15","objectID":"/posts/uml-class-diagram/:2:0","tags":["java"],"title":"UML类图","uri":"/posts/uml-class-diagram/"},{"categories":["java"],"content":"泛化（Generalization） 在Java中也叫作继承关系 空心三角箭头 Studen类，警察Policemen类，均继承自Person类 ","date":"2023-05-15","objectID":"/posts/uml-class-diagram/:2:1","tags":["java"],"title":"UML类图","uri":"/posts/uml-class-diagram/"},{"categories":["java"],"content":"实现（Realization） Java中类与接口的实现关系 空心三角箭头加虚线 由于Student和Policeman都是职业，学生的职业就是学习，而警察的职业为保护人民。所有定义一个职业接口。 ","date":"2023-05-15","objectID":"/posts/uml-class-diagram/:2:2","tags":["java"],"title":"UML类图","uri":"/posts/uml-class-diagram/"},{"categories":["java"],"content":"依赖（Dependence） 依赖关系是一种很弱的关系，一般是指一个类使用另一个类 带箭头的虚线 这里学生捡到钱交给警察叔叔，学生和警察叔叔就是一种依赖关系。 因为学生捡到钱给警察是一种偶然的事情，交给警察后他们之间就没有关系了。 ","date":"2023-05-15","objectID":"/posts/uml-class-diagram/:2:3","tags":["java"],"title":"UML类图","uri":"/posts/uml-class-diagram/"},{"categories":["java"],"content":"关联（Association） 比较强的关系，他们的关系是比较持久的，稳定的（一个类作为另一个类的属性） 分单向关联和双向关联 单向关联：带箭头的实线 ","date":"2023-05-15","objectID":"/posts/uml-class-diagram/:2:4","tags":["java"],"title":"UML类图","uri":"/posts/uml-class-diagram/"},{"categories":["java"],"content":"聚合（Aggregation） 特殊的关联关系（强调整体和部分的关系，部分可以脱离整体而存在） 带空心菱形的实线（其中菱形指向整体） 警察与制服的关系，制服也是警察的一部分，制服可以脱离警察而存在 ","date":"2023-05-15","objectID":"/posts/uml-class-diagram/:2:5","tags":["java"],"title":"UML类图","uri":"/posts/uml-class-diagram/"},{"categories":["java"],"content":"组合（Composition） 特殊的关联关系（强调整体和部分的关系，部分无法脱离整体存在） 带空心菱形的实线（其中菱形指向整体） 学生用手捡钱，其中手就是学生的一部分，但是手不能脱离学生而单独存在 ","date":"2023-05-15","objectID":"/posts/uml-class-diagram/:2:6","tags":["java"],"title":"UML类图","uri":"/posts/uml-class-diagram/"},{"categories":["java"],"content":"按关系强度：组合\u003e聚合\u003e关联\u003e依赖。 图是用PlantUML画的 @startuml interface ICareer { +career() } class Persion { -name:String -age:Integer = 1 +setName(String name):void +getName():String +setAge(String age):void +getAge():String } class Student { +policeman:Policeman +teacher:Teacher +home:Home +hand:Hand +sendCoin() } class Hand { } class Home { } class Teacher { +student:Student } class Policeman { +uniform:Uniform +receiveCoin() } class Uniform { } ICareer \u003c|.down. Student:实现 ICareer \u003c|.down. Policeman:实现 Persion \u003c|-down- Student:继承 Persion \u003c|-down- Policeman:继承 Student .\u003e Policeman:依赖 Student -left\u003e Home:单向关联 Student -left Teacher:双向关联 Student *-down- Hand:组合 Uniform -up-o Policeman:聚合 @enduml ","date":"2023-05-15","objectID":"/posts/uml-class-diagram/:2:7","tags":["java"],"title":"UML类图","uri":"/posts/uml-class-diagram/"},{"categories":["tools"],"content":" PlantUML是一个开源项目，支持快速绘制： 时序图、用例图、类图、对象图、活动图、组件图、部署图、状态图和定时图。 中文官网地址： https://plantuml.com/zh/ 如果想绘制除 时序图和活动图以外的图, 就需要安装 Graphviz 软件 Graphviz下载地址： https://graphviz.org/download/ MAC直接使用命令brew install graphviz安装 IDEA安装插件 PlantUML integration 画图时通过File–\u003eNew–\u003ePlantUml File创建文件，选择对应的图即可。 个人最常使用的感觉还是PlantUML的时序图和类图。 时序图的语法和功能： https://plantuml.com/zh/sequence-diagram 类图的语法和功能： https://plantuml.com/zh/class-diagram ","date":"2023-05-15","objectID":"/posts/drawing-with-plantuml/:0:0","tags":null,"title":"使用PlantUML画图","uri":"/posts/drawing-with-plantuml/"},{"categories":["java"],"content":"1 多线程相关概念 ","date":"2023-05-13","objectID":"/posts/java-multithreading/:0:0","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"1.1 线程和进程 ","date":"2023-05-13","objectID":"/posts/java-multithreading/:1:0","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"1.1.1 什么是线程？什么是进程？ 进程：是指内存中运行的一个应用程序，每个进程都有自己独立的内存空间；进程也是程序的一次执行过程，是系统运行程序的基本单位; 系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：是进程中的一个执行单元，负责当前进程中任务的执行。一个进程在其执行过程中，会产生很多个线程。 从操作系统角度来看， 从用户态来看，创建进程其实就是启动一个项目。但是这个项目需要人去执行。有多个人并行执行不同的部分，这就叫多线程 （Multithreading）。如果只有一个人，那它就是这个项目的主线程。 但是从内核态来看，无论是进程，还是线程，我们都可以统称为任务（Task），都使用相同的数据结构task_struct ，平放在同一个链表中。该数据结构中包含 pid, tgid 两个字段，通过对比 pid 和 tgid 可判断是进程还是线程。 ","date":"2023-05-13","objectID":"/posts/java-multithreading/:1:1","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"1.1.2 进程与线程的区别？ 进程：有独立内存空间，每个进程中的数据空间都是独立的。 线程：多线程之间堆空间与方法区是共享的，但每个线程的栈空间、程序计数器是独立的，线程消耗的资源比进程小的多。 ","date":"2023-05-13","objectID":"/posts/java-multithreading/:1:2","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"1.1.3 什么是多线程？ 多线程（multithreading）是指从软件或者硬件上实现多个线程并发执行的技术。 ","date":"2023-05-13","objectID":"/posts/java-multithreading/:1:3","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"1.1.4 并发与并行的区别？ 并发（Concurrent）：同一时间段，多个任务都在执行 ，单位时间内不⼀定同时执行 并行（Parallel）：单位时间内，多个任务同时执行，单位时间内一定是同时执行 并发是一种能力，并行是一种手段 ","date":"2023-05-13","objectID":"/posts/java-multithreading/:1:4","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"1.1.5 什么是线程上下文切换？ 一个CPU内核，同一时刻只能被一个线程使用。为了提升CPU利用率，CPU采用了时间片算法将CPU时 间片轮流分配给多个线程，每个线程分配了一个时间片（几十毫秒/线程），线程在时间片内，使用CPU 执行任务。当时间片用完后，线程会被挂起，然后把 CPU 让给其它线程。 CPU切换前会把当前任务状态保存下来，用于下次切换回任务时再次加载。 任务状态的保存及再加载的过程就叫做上下文切换。 保存在哪里？程序计数器 过多的线程并行执行会导致CPU资源的争抢，产生频繁的上下文切换，常常表现为高并发执行时，RT延长。 ","date":"2023-05-13","objectID":"/posts/java-multithreading/:1:5","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"1.1.6 java线程的生命周期？ 查看Thread源码，能够看到java的线程有六种状态： public enum State { NEW, //创建但并未启动 RUNNABLE, //线程在Java虚拟机中处于可以运行的状态，是否正在执行取决于操作系统处理器 BLOCKED, //试图获取到锁但没有得到后处于这个状态 WAITING, //无法自动唤醒，必须等待另一个线程调用notify或者notifyAll TIMED_WAITING, //这一状态将一直保持到超时期满或者接收到唤醒通知 TERMINATED; //被终止。因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡 } Java线程常用方法： 线程让步：yield() 让线程休眠的方法：sleep() 等待线程执行终止的方法： join() 线程中断interrupt() 等待与通知系列函数wait()、notify()、notifyAll() wait()与sleep()区别 主要区别：sleep()方法没有释放锁，而wait()方法释放了锁 两者都可以暂停线程的执行 wait()通常用于线程间的交互/通信，sleep()通常用于暂停线程执行 wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象的notify或notifyAll。 sleep()方法执行完成后，线程会自动苏醒。或者可以使用wait(long)超时后，线程也会自动苏醒 ","date":"2023-05-13","objectID":"/posts/java-multithreading/:1:6","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"1.2创建线程在JVM中的实现原理 线程类被JVM加载时，完成线程所有native方法和C++中的对应方法绑定。 Java线程调用start方法：start方法==\u003enative state0方法==\u003eJVM_StartThread==\u003e创建JavaThread::JavaThread线程 创建OS线程，并指定OS线程的运行入口：创建JavaThread::JavaThread线程==\u003e创建OS线程os::create_thread==\u003e 指定OS线程执行入口Java线程的run方法 启动OS线程：运行时会调用Java线程的run方法，至此实现了Java线程的运行。 创建线程的时候使用的是互斥锁MutexLocker操作系统（互斥量），所以说创建线程是一个性能很差的操作！ ","date":"2023-05-13","objectID":"/posts/java-multithreading/:2:0","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"1.3线程安全问题 ","date":"2023-05-13","objectID":"/posts/java-multithreading/:3:0","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"1.3.1什么是线程安全？ 如果有多个线程在同时执行，而多个线程可能会同时运行一行代码。如果程序每次运行结果和单线程运行的结果一样，且其他的变量的值也和预期一样，就是线程安全的，反之则是线程不安全的。 线程安全问题都是由全局变量及静态变量【共享】引起的。 如果每个线程中对全局变量、静态变量只有读操作，而无写操作，那么这个全局变量是线程安全的； 如果有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全问题。 如何解决线程安全问题？ 线程同步 volatile JUC 原子类（CAS） 锁（AQS） ","date":"2023-05-13","objectID":"/posts/java-multithreading/:3:1","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"1.3.2线程同步 同步代码块 synchronized(同步锁){ //需要同步操作的代码 } 同步方法 //同步方法 public synchronized void method(){ //可能会产生线程安全问题的代码 } Lock锁 Lock lock=new ReentrantLock();//可重入锁 lock.lock(); //需要同步操作的代码 lock.unlock(); ","date":"2023-05-13","objectID":"/posts/java-multithreading/:3:2","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"1.4 多线程并发的三个特性 ","date":"2023-05-13","objectID":"/posts/java-multithreading/:4:0","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"1.4.1 并发编程中哪三个重要特性 原子性：即一个操作或多个操作，要么全部执行，要么就都不执。 有序性：程序代码按照先后顺序执行 为什么会出现无序问题呢？因为指令重排 指令重排是编译器和处理器为了提高程序运行效率，会对输入代码进行优化的一种手段。它不保证程序中，各个语句执行先后顺序的一致。 可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值 为什么出现不可见性问题呢？可以说是因为Java内存模型【JMM】 ","date":"2023-05-13","objectID":"/posts/java-multithreading/:4:1","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"1.4.2 Java内存模型 诞生背景是因为CPU的缓存一致性、指令重排优化。 Java为了保证并发编程中可以满足原子性、可见性及有序性，诞生出了一个重要的概念，那就是内存模型， 内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性，它解决了 CPU 多级缓存、处理器优化、指令重排等导致的内存访问问题。 内存模型如何解决并发问题？ 1.限制处理器优化、2.使用内存屏障 JMM中定义一个共享变量何时写入，何时对另一个线程可见 Java中关键字Synchronized、Volatile JMM线程操作内存的基本规则 线程与主内存：线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存中读写 线程间本地内存：不同线程之间无法直接访问其他线程本地内存中的变量，线程间变量值的传递需要经过主内存 ","date":"2023-05-13","objectID":"/posts/java-multithreading/:4:2","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"1.4.3 happens-before规则 在JMM中，使用happens-before规则来约束编译器的优化行为，允许编译期优化，但需要遵守一定的Happens-Before规则。 如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before的关系。 需关注的happens-before规则： 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。 锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。 volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。 2 synchronized synchronized可以保证并发程序的原子性，可见性，有序性。 synchronized可以修饰方法和代码块。 方法：可修饰静态方法和非静态方法 代码块：同步代码块的锁对象可以为当前实例对象、字节码对象（class）、其他实例对象 ","date":"2023-05-13","objectID":"/posts/java-multithreading/:4:3","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"2.1 synchronized解决内存可见性的原理 线程解锁前：必须把自己本地内存中共享变量的最新值刷新到主内存中 线程加锁时：将清空本地内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值 ","date":"2023-05-13","objectID":"/posts/java-multithreading/:5:0","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"2.2 同步原理 同步操作主要是monitorenter和monitorexit两个指令实现，背后原理是Monitor（管程） 同步代码块 对应的monitorenter和monitorexit指令分别对应synchronized同步块的进入和退出 为什么会多一个monitorexit? 因为编译器会为同步块添加一个隐式的try-finally，在finally中会调用monitorexit命令释放锁 同步方法 JVM进行方法调用时，发现调用的方法被ACC_SYNCHRONIZED修饰，则会先尝试获得锁，方法调用结束了释放锁。 底层依然是monitorenter和monitorexit指令 ","date":"2023-05-13","objectID":"/posts/java-multithreading/:6:0","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"2.3 Monitor(管程) 管程(Monitor)：是管理共享变量及对共享变量操作的过程，将共享变量和对共享变量的操作统一封装起来，让这个过程可以并发执行。 为什么所有对象都可以作为锁？ 因为每个对象都都有一个Monitor对象与之关联。然后线程对monitor执 行lock和unlock操作，相当于对对象执行上锁和解锁操作。 Java并没有把lock和unlock操作直接开放给用户使用，但是却提供了两个指令来隐式地使用这两个操作：moniterenter和moniterexit。moniterenter 对应lock操作，moniterexit对应unlock操作， 通过这两个指令锁定和解锁 monitor 对象来实现同步。 当一个monitor对象被线程持有后，它将处于锁定状态。对于一个 monitor 而言，同时只能有一个线程能锁定monitor，其它线程试图获得已被锁定的 monitor时，都将被阻塞。当monitor被释放后，阻塞中的线程会尝试获得该 monitor锁。一个线程可以对一个 monitor 反复执行 lock 操作，对应的释放锁时，需要执行相同次数的 unlock 操作。 ","date":"2023-05-13","objectID":"/posts/java-multithreading/:7:0","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"2.4 锁优化 什么是锁优化？ 同步锁一共有四个状态：无锁，偏向锁，轻量级锁，重量级锁，JVM会视情况来逐渐升级锁，而不是上来就加重量级锁 偏向锁 只有一个线程访问锁资源（无竞争）的话，偏向锁就会把整个同步措施都消除。 轻量级锁 只有两个线程交替运行时，如果线程竞争锁失败了，先不立即挂起，而是让它飞一会儿（自旋），在等待过程中，可能锁就被释放了，这时线程重新尝试获取锁。 同步锁锁定的资源是对象，存储在对象头中。 偏向锁标记 锁状态标识 锁状态 0 01 无锁 1 01 偏向锁 无 00 轻量锁 无 10 重量锁 无 11 GC标记 锁升级 锁可以升级但不能降级 偏向锁：是指当一段同步代码一直被同一个线程所访问时，即不存在多个线程的竞争 时，那么该线程在后续访问时便会自动获得锁，从而降低获取锁带来的消耗，即提高性能。 轻量级锁：（自旋锁）是指当锁是偏向锁的时候，却被另外的线程所访问 ，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，线程同样不会阻塞。长时间的自旋操作是非常消耗资源的， 一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做忙等（busy-waiting） 重量级锁：此忙等是有限度的。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起 （而不是忙等），等待将来被唤醒。有个计数器记录自旋次数，默认允许循环10次，可以通过虚拟机参数更改 3 volatile volatile可以保证多线程场景下共享变量的可见性、有序性。 可见性：保证对此共享变量的修改，所有线程的可见性 有序性：禁止指令重排序的优化，遵循JMM的happens-before规则 ","date":"2023-05-13","objectID":"/posts/java-multithreading/:8:0","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"3.1 volatile实现内存可见性的过程 // 添加volatile关键词 private volatile boolean flag=true; 线程写volatile变量的过程： 改变线程本地内存中volatile变量副本的值； 将改变后的副本的值从本地内存刷新到主内存 线程读volatile变量的过程： 从主内存中读取volatile变量的最新值到线程的本地内存中 从本地内存中读取volatile变量的副本 ","date":"2023-05-13","objectID":"/posts/java-multithreading/:9:0","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"3.2 volatile实现原理 内存屏障（Memory Barrier）是CPU的一种指令，用于控制特定条件下的重排序和内存可见性问题。 Java编译器会根据内存屏障的规则禁止重排序。 写操作时，通过在写操作指令后加入一条store屏障指令，让本地内存中变量的值能够刷新到主内存中 读操作时，通过在读操作前加入一条load屏障指令，及时读取到变量在主内存的值 ","date":"2023-05-13","objectID":"/posts/java-multithreading/:10:0","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"3.3 volatile缺陷 原子性问题 static class VolatileDemo implements Runnable { public volatile int count; public void run() { addCount(); } public void addCount() { for (int i = 0; i \u003c 10000; i++) { count++;//实际是三条汇编指令 } } } 解决方法 使用synchronized public synchronized void addCount() 使用ReentrantLock（可重入锁） private Lock lock = new ReentrantLock(); public void addCount() { for (int i = 0; i \u003c 10000; i++) { lock.lock(); count++; lock.unlock(); } } 使用AtomicInteger（原子操作） public static AtomicInteger count=new AtomicInteger(0); public void addCount(){ for(int i=0;i\u003c 10000;i++){ count.incrementAndGet(); } } ","date":"2023-05-13","objectID":"/posts/java-multithreading/:11:0","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"3.4 volatile使用场景 变量真正独立于其他变量和自己以前的值，在单独使用的时适合用volatile 对变量的写入操作不依赖其当前值：例如++和–运算符的场景则不行 该变量没有包含在具有其他变量的不变式中 ","date":"2023-05-13","objectID":"/posts/java-multithreading/:12:0","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["java"],"content":"3.5 synchronized和volatile比较 volatile不需要加锁，比synchronized更轻便，不会阻塞线程 synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性 与synchronized相比，volatile是一种非常简单的同步机制 ","date":"2023-05-13","objectID":"/posts/java-multithreading/:13:0","tags":["java"],"title":"Java并发编程基础","uri":"/posts/java-multithreading/"},{"categories":["books"],"content":" 作者：周岭 ","date":"2023-04-23","objectID":"/posts/cognitive-awakening/:0:0","tags":["books"],"title":"《认知觉醒》","uri":"/posts/cognitive-awakening/"},{"categories":["books"],"content":"自序 所谓心智，通俗地说，就是我们看待人和事的态度，以及由此做出判断的选择。每一个人来到这个世界时，其人生观、世界观、价值观全部都是从零开始，所有习性、 习惯、模式也要从人性的初始状态开始发展。 2017年，我36岁。我发现每天有事情做不代表觉醒，每天都努力也不代表觉醒，真正的觉醒是一种发自内心的渴望，立足长远，保持耐心，运用认知的力量与时间 做朋友；我发现人与人之间的根本差异是认知能力上的差异，因为认知影响选择，而选择改变命运，所以成长的本质就是让大脑的认知变得更加清晰；我开始广泛涉 猎知识，从脑科学、认知科学、心理学、行为科学、社会学及其他学科中，看到了自己成长的可能性，明白了自己想要什么，清楚了部分规律和真相，知道了实现梦 想的方法和路径…… ","date":"2023-04-23","objectID":"/posts/cognitive-awakening/:1:0","tags":["books"],"title":"《认知觉醒》","uri":"/posts/cognitive-awakening/"},{"categories":["books"],"content":"第一章 大脑——一切问题的起源 ","date":"2023-04-23","objectID":"/posts/cognitive-awakening/:2:0","tags":["books"],"title":"《认知觉醒》","uri":"/posts/cognitive-awakening/"},{"categories":["books"],"content":"三重大脑 本能脑 爬行动物、原始的条件反射 农夫和蛇：蛇没有情绪脑，不懂感恩 情绪脑 哺乳动物、恐惧——\u003e远离危险；兴奋——\u003e专注捕猎；愉悦——\u003e增强同伴亲密度；悲伤——\u003e引来同情者关爱 理智脑 源于灵长动物时代，主管认知 理智脑的力量弱小： 诞生的最晚，最不发达 发育成熟时间不同：本能脑在婴儿时期2岁完善；情绪脑在青少年时期12岁完善；理智脑在成年早期22岁完善 本能脑和情绪脑占据近八成的活跃神经元细胞，且离心脏更近，优先得到供血。为什么极度紧张时大脑空白？因为处于最外层的理智脑缺血了。 本能脑和情绪脑掌管着潜意识和生理系统，运行速度极快。而理智脑最快运行速度仅40次/秒，且非常耗能。 所以我们在生活中做的大部分决策往往源于本能和情绪，而非理智。 我们当前遇到的几乎所有成长问题都可以归结为避难趋易和急于求成的天性。 避难趋易 只做简单和舒适的事，喜欢在核心区域周边打转，待在舒适区内逃避真正的困难； 急于求成 凡事希望立即看到结果，对不能马上看到结果的事往往缺乏耐心，非常容易放弃。 大多数时候我们以为自己在思考，其实都是在对自身的行为和欲望进行合理化。 ","date":"2023-04-23","objectID":"/posts/cognitive-awakening/:2:1","tags":["books"],"title":"《认知觉醒》","uri":"/posts/cognitive-awakening/"},{"categories":["books"],"content":"焦虑的根源 无论个体还是群体，人类的安全感都源于自己在某一方面拥有的独特优势：或能力，或财富，或权利，或影响力。 焦虑的几种形式： 完成焦虑 日程被打乱，每天活在deadline面前 定位焦虑 目标定位太高，无法达成 选择焦虑 选择困难症 环境焦虑 被工作、家庭束缚 难度焦虑 学习本身很难掌握的知识 焦虑的根源 想同时做很多事，又想立即看到效果。 往深了说：急于求成，想同时做很多事；避难趋易，想不怎么努力就立即看到效果。 ","date":"2023-04-23","objectID":"/posts/cognitive-awakening/:2:2","tags":["books"],"title":"《认知觉醒》","uri":"/posts/cognitive-awakening/"},{"categories":["books"],"content":"耐心 学习的复利曲线：前期增长非常缓慢，但达到一个拐点后会飞速增长。 面对诱惑，学会延迟满足。“该有的享受一点都不会少，只是不是现在享受，而是在完成重要的事情之后。” ","date":"2023-04-23","objectID":"/posts/cognitive-awakening/:2:3","tags":["books"],"title":"《认知觉醒》","uri":"/posts/cognitive-awakening/"},{"categories":["books"],"content":"第二章 潜意识——生命留给我们的彩蛋 大脑需要处理的信息是海量的。为了更好地生存，进化之手采取了意识分层的手段，让潜意识负责生理系统，让意识负责社会系统。 意识分层的副作用：模糊。因为处理信息的速度不对等，意识很难介入潜意识，而潜意识却能轻易左右意识，所以人们总是做着自己不理解的事，比如明明想 去学习，结果转身拿起了手机；明明知道有些担忧毫无意义，却总是忍不住陷入焦虑。 学习知识的目的是\"消除模糊\"。 消除情绪模糊： 任何痛苦事件不会自动消失。唯一的办法就是正视它，不给它进入潜意识变模糊的机会。赶紧坐下来，向自己提问。坦然地承认、接纳那些难以启齿的想法，让 情绪极度透明。 消除行动模糊： 人类面对不确定性时会不自觉逃避。当我们没有足够清晰的指令或者目标时，就很容易选择享乐，放弃那些本该坚持但比较烧脑但选项。 在诸多可能性中建立一条单行通道，让自己始终处于一种没得选的状态。 ","date":"2023-04-23","objectID":"/posts/cognitive-awakening/:3:0","tags":["books"],"title":"《认知觉醒》","uri":"/posts/cognitive-awakening/"},{"categories":["books"],"content":"第三章 元认知——人类的终极能力 元认知能力总能让你站在高处俯瞰全局，不会让你一头扎进生活的细节，迷失其中。 提高元认知能力最有效的方法是冥想。冥想就是静坐，放松身体，把注意力完全集中到呼吸和感受上的活动。通过持续锻炼，大脑可以直接从物理上提升元认 知能力，如果过程中觉察到自己走神了，只需柔和地将注意力拉回来。 元认知能力就是觉察力和自控力的组合。从实用角度讲，元认知能力可以被重新定义为：自我审视、主动控制，防止被潜意识左右的能力。 成长就是为了主动控制。 理智脑的战斗力表现在两个方面： 一方面是侧重学习、理解、记忆、运算的认知能力，即我们在校学习时主动锻炼的部分； 另一方面则是侧重观察、反思、判断、选择的元认知能力。 看抖音停不下来的原因：大脑被本能和情绪劫持，理智脑根本没有主动启动的机会。 每当遇到需要选择的情况时，我们要是能先停留几秒思考一下，就有可能激活自己的理智脑，启用元认知来审视当前的思维，然后做出不一样的选择。 一定要在选择节点上多花\"元时间\"。 书中将一天中权重大的时间叫\"元时间\"。元时间通常分布在\"选择的节点\"上，比如一件事情、一个阶段或一天开始或结束时。善用这些时间会极大程度地优化后续 时间的质量。“元时间\"内做什么？就做一件事：想清楚。 如果不在这些选择的节点想清楚，我们就会陷入模糊状态，而模糊是潜意识的领地，它会使我们产生本能的反应——娱乐。所以基本的应对策略是： 在选择的节点审视自己的第一反应，并产生清晰明确的主张。 元认知能力强的一个突出表现就是：对模糊零容忍。 ","date":"2023-04-23","objectID":"/posts/cognitive-awakening/:4:0","tags":["books"],"title":"《认知觉醒》","uri":"/posts/cognitive-awakening/"},{"categories":["books"],"content":"第四章 专注力——情绪和智慧的交叉地带 审视自己的注意力——是被动吸引还是主动选择？ 审视自己的沉浸度——是分心走神还是极度专注？ 审视自己的练习量——是浅尝辄止还是大量投入？ ","date":"2023-04-23","objectID":"/posts/cognitive-awakening/:5:0","tags":["books"],"title":"《认知觉醒》","uri":"/posts/cognitive-awakening/"},{"categories":["books"],"content":"第五章 学习力——学习不是一味地努力 深度学习的能力几乎全部依赖高级理智脑的支撑。 深度学习有以下三个步骤： 获取高质量的知识；（尽可能获取并亲自钻研一手知识） 深度缝接新知识；（尽可能用自己的话把所学的知识写下来） 输出成果去教授。（反思生活。 人与人之间的差距不是来自年龄，甚至不是来自经验，而是来自经验总结、反思和升华的能力。） 知识的获取不在于多少，而在于是否与自己有关联，以及这种关联有多充分。当然，还有一个前提，你需要明确的目标或强烈的需求。 知识与认知的区别： “考试得了高分，不叫有知识；茶余饭后能高谈阔论，这也不叫有知识。这些场合下，知识虽然有用，但是这些知识都不太牵扯到具体的得失，所以只是智力游戏。 只有当局势不明朗、没有人告诉你该怎么办，而错误的判断又会导致一些不良后果时，你要是能因为有知识而敢于拿一个主意，这才算是真有知识。请注意，这 不是在说，实用的知识才是知识，而是在说，只有当知识能够帮助你做实际决策的时候，它才是你的知识。” 在个人成长领域，没有最优、最确定、最权威的认知体系，只有最适合我们自己当前状态的认知体系。 体系的本质就是用独特的视角将一些零散的、独立的知识、概念或观点整合为应对这个世界的方法和技巧。 搭建个人认知体系的真相：打碎各家的认知体系，只取其中最触动自己的点或块，然后将其拼接成自己的认知网络。 获取知识时寻找触动点。 在需要的时候能够顺利提取知识，提取不出来的知识就是伪触动。 在生活中需要经常练习或使用这些知识，实践是产生强关联的终极方法。 痛苦也是一种反馈。 首先，分享不是随意分享半成品，而是尽自己最大力气将作品打磨成自己当前能力范围内可完成的最好的样子。 其次，制定分享策略，展示给那些能力不及你的人。 最后，冷静客观地对待打击。 真正的学习成长不是\"努力，努力再努力”，而是\"反馈，反馈再反馈\"。 意志失控的根源是精力不足。 克服困难和抵制诱惑都需要消耗意志力。 一个真正的自控高手，不是一个只知道冲刺的人，而是一个善于主动休息、保持平衡的人。 ","date":"2023-04-23","objectID":"/posts/cognitive-awakening/:6:0","tags":["books"],"title":"《认知觉醒》","uri":"/posts/cognitive-awakening/"},{"categories":["books"],"content":"第六章 行动力——没有行动，世界只是个概念 清晰力才是行动力。 成长是个系统工程。从某种程度上说，有自己热爱的事，比行动力本身要重要的多。因为一旦有了热情，就会自带\"要事第一\"和\"提高清晰力\" 等各种属性。 知行合一怎么实践？绝大多数人都是知而不行。 认知其实一种技能。学习任何一门技能，本质上都是大脑中的神经细胞在建立连接。 通过大量的重复运动，大脑中两个或者多个原本并不关联的神经元 受到反复刺激之后产生了强关联。 不发生真正改变的学习都是无效的学习。 ","date":"2023-04-23","objectID":"/posts/cognitive-awakening/:7:0","tags":["books"],"title":"《认知觉醒》","uri":"/posts/cognitive-awakening/"},{"categories":["books"],"content":"第七章 情绪力——情绪是多角度看问题的智慧 ","date":"2023-04-23","objectID":"/posts/cognitive-awakening/:8:0","tags":["books"],"title":"《认知觉醒》","uri":"/posts/cognitive-awakening/"},{"categories":["books"],"content":"心智带宽：唯有富足，方能解忧 稀缺心态，让人变笨。 任何能制造压力的事件，都会挤占我们的心智带宽。 贫穷、短缺、deadline都会造成稀缺心态。 只要我们的注意力被某一个巨大的事物吸引，我们就有可能进入稀缺状态，进而降低心智带宽，做出不明智的行为。 多任务并行时，会降低心智带宽，反而没有了行动力和自控力。 抵制诱惑和欲望会消耗心智带宽。 ","date":"2023-04-23","objectID":"/posts/cognitive-awakening/:8:1","tags":["books"],"title":"《认知觉醒》","uri":"/posts/cognitive-awakening/"},{"categories":["books"],"content":"你的坏情绪，源于视角单一 世界是多维的，而我们只有一双眼睛。 ","date":"2023-04-23","objectID":"/posts/cognitive-awakening/:8:2","tags":["books"],"title":"《认知觉醒》","uri":"/posts/cognitive-awakening/"},{"categories":["books"],"content":"游戏心态：幸福的人，总是在做另外一件事 幸福源自自主掌控。人类有三种天生的内在需求：关系需求、能力需求和自主需求。 换句话说，一个人想要生活幸福，需要具备以下因素。 有良好的人际关系，得到别人的爱与尊敬； 有独特的本领、技能，为他人带去独特价值； 有自主选择的权力，能做自己想做的事情。 ","date":"2023-04-23","objectID":"/posts/cognitive-awakening/:8:3","tags":["books"],"title":"《认知觉醒》","uri":"/posts/cognitive-awakening/"},{"categories":["books"],"content":"第八章 早冥读写跑，人生五件套 ","date":"2023-04-23","objectID":"/posts/cognitive-awakening/:9:0","tags":["books"],"title":"《认知觉醒》","uri":"/posts/cognitive-awakening/"},{"categories":["books"],"content":"早起 中岛孝志《4点起床：最养生和高效的时间管理》 书中提到的有关睡眠的脑科学理论 芝加哥大学实验发现，人的眼球会在睡觉时候来回运动，从而得出\"快速眼动睡眠\"（REM）和\"非快速眼动睡眠\"（Non-REM）规律。 健康的成年人睡觉时大多数是1.5小时快速眼动睡眠、1.5小时非快速眼动睡眠，两种模式不断切换，并且在最初的两个单位时间内，也就是睡着之后的前3个 小时中，会进行高质量的睡眠（深度非快速眼动睡眠等于熟睡），之后则是浅层非快速眼动睡眠与快速眼动睡眠的组合。 根据这一规律，人在睡眠后的3小时、4.5小时、6小时、7.5小时这几个节点醒来，就会觉得神清气爽，精力充沛。很多时候睡了很长时间依然精神不佳，原 因是醒来的时机不在睡眠节点上。 闹钟不会照顾你的睡眠周期。 抓住大脑工作的高峰期 人体从黎明开始分泌肾上腺素和肾上腺皮质类脂醇这两种可以让人保持精力充沛的荷尔蒙，分泌高峰期正好是早上7点左右，这个时候人的工作效率非常高。 人进食后，能量也会在1小时后转变为葡萄糖，输送到大脑，人的记忆力、理解力就会提高，大脑的运转速度会迎来峰值，直至4小时后才降到谷底。 午饭后的效率峰值在14点到16点间出现。 一旦认知上想通想透了，行动上就不需要用大把大把的意志力来支撑了。 早起做哪些事 规划 跑步 反思 读书或写作（自我提升的非常好的整块时间） 困难的工作 早起的收获 清晰的时间安排 强健的体魄 良好的精神状态 不受干扰的锻炼氛围 专注的学习环境 从容的工作心态 持续的个人成长 ","date":"2023-04-23","objectID":"/posts/cognitive-awakening/:9:1","tags":["books"],"title":"《认知觉醒》","uri":"/posts/cognitive-awakening/"},{"categories":["books"],"content":"冥想 普通人和聪明人最大的能力差异是长时间保持极度专注的能力。 成绩好的人的真正优势在于，他们能够长时间让\"7个小球\"同时关注一件事情，以保证高质高效的学习，而在成绩不好的人脑中，很可能一个球在播放背景音乐， 一个球在想晚上吃什么，一个球在担心即将到来的考试。 在冥想过程中，我们仅需把注意力全部集中到呼吸上，也就是说，让7个小球同时做一件事，如果其中某个小球\"走神\" 了，把它柔和地拉回来即可。坚持这种练习， 你就能养成专注的习惯，将专注变成无意识的行为，在不冥想时也能自动抑制思维离散，控制涣散的精神。换句话说，“7个小球” 都能在需要的时候为你所用。 科学研究表明，通过这种集中注意力的冥想练习，人大脑皮层表面积增大，大脑灰质变厚，这意味着这种练习可以从物理上让我们变得更加聪明，因为一个人大脑 皮层表面积和大脑灰质厚度是影响人聪明程度的因素。 ","date":"2023-04-23","objectID":"/posts/cognitive-awakening/:9:2","tags":["books"],"title":"《认知觉醒》","uri":"/posts/cognitive-awakening/"},{"categories":["books"],"content":"阅读 想要快速成为一个行业的高手，最好的方法就是和行业专家交流，直接向他们请教。 但现实是普通人很少有这样的机会与资源。怎么办？阅读。 读书就是用最低廉的成本获取最高级的成长策略。 只要选书得当，几乎所有的书籍都是智者看待事物、做选择、决策的过程。 我们生活中的待人接物、安排日程、组织活动、开汽车、用手机等，思考密度其实很低的。绝大多数时候只是调用原有的记忆模块，顺着习惯做出反应而已，真正 思考其实并不多。而阅读，让人拥有高密度的思考。 ","date":"2023-04-23","objectID":"/posts/cognitive-awakening/:9:3","tags":["books"],"title":"《认知觉醒》","uri":"/posts/cognitive-awakening/"},{"categories":["books"],"content":"写作：费曼 无论学习什么东西，都要努力琢磨它们究竟在讲什么，它们的实际意义是什么，然后用自己的话将其重新讲出来。 先用合适的故事引起对方\"感性小人\"的兴趣和注意，然后把想要表达的道理通过\"感性小人\"转达给\"理性小人\"。 ","date":"2023-04-23","objectID":"/posts/cognitive-awakening/:9:4","tags":["books"],"title":"《认知觉醒》","uri":"/posts/cognitive-awakening/"},{"categories":["books"],"content":"运动 **好的事物往往是正相关的。**如果一个人一方面很突出，那他其他方面不会差。 运动能够是大脑长出更多的新的神经元，这意味着运动可以在物理上让人变得更\"聪明\"。 有效的模式是：在运动后的1～2小时内进行高强度、高难度的脑力活动，比如阅读、背诵、编程等，以及参加不同于以往的社交活动，如接触新的环境、人物或 事物，那么这样做可以让新的神经元收到刺激，不断生长。换句话说，运动之后，脑子需要充分接受考验或者挑战，才能让自己不断地变聪明。绝大多数运动者的 硬伤在于运动之后缺乏主动学习的意识和习惯。 好的运动方式一定同时包含有氧运动和复杂运动。 ","date":"2023-04-23","objectID":"/posts/cognitive-awakening/:9:5","tags":["books"],"title":"《认知觉醒》","uri":"/posts/cognitive-awakening/"},{"categories":["books"],"content":"结语 每日反思可以提高自己对时间的敏感度。 复盘方式： 描述经过——以便日后回顾时能想起当时的场景。 分析原因——多问几个为什么，直到有深度的启发。 改进措施——尽可能提炼出一个认知点或行动点。 无论何时，都要把对方的情绪和意见分开对待，这样，即使在最糟糕的事情中也能学到有用的东西。 有了这些认知晶石打底，我们的生命质量和密度将远远超过那些不反思的人。 每日反思至少蕴含了三大底层原理： 符合触动学习法 运用了元认知 遵循了刻意练习的原则 行动起来 不必形式束缚 尽量提炼认知点或行动点。不要情绪释放或碎碎念 列行动清单 对自己要坦诚 要多阅读 使用电子文档，石墨文档或者印象笔记 一个人觉醒的起点到底在哪里？觉知。当一个人能够觉知到什么是好，什么是不好的时候，就必然会主动做出新的选择。即使你没有万贯家财，也可以通过提升 觉知来增强自己感知世界、完善自我的能力。有了觉知，我们就能慢慢过上一流的生活，即使它来的不会那么快。 ","date":"2023-04-23","objectID":"/posts/cognitive-awakening/:10:0","tags":["books"],"title":"《认知觉醒》","uri":"/posts/cognitive-awakening/"},{"categories":["java"],"content":"注解格式 //元注解 public @interface 注解名称 { 属性列表; } 注解本质上就是一个接口，该接口默认继承Annotation接口。任何注解默认继承Annotation接口 举例： public @interface Student { String name(); // 姓名 int age() default 18; // 年龄 String gender() default \"男\"; // 性别 } // 该注解就有了三个属性：name，age，gender ","date":"2023-04-16","objectID":"/posts/java-custom-annotation/:0:0","tags":["java"],"title":"Java自定义注解","uri":"/posts/java-custom-annotation/"},{"categories":["java"],"content":"注解属性 属性作用：可以让用户在使用注解时传递参数，让注解的功能更加强大。 属性格式 格式1：数据类型 属性名(); 格式2：数据类型 属性名() default 默认值; 适用数据类型 八种基本数据类型（int,float,boolean,byte,double,char,long,short)。 String类型，Class类型，枚举类型，注解类型。 以上所有类型的一维数组。 ","date":"2023-04-16","objectID":"/posts/java-custom-annotation/:1:0","tags":["java"],"title":"Java自定义注解","uri":"/posts/java-custom-annotation/"},{"categories":["java"],"content":"使用自定义注解 使用格式： @注解名(属性名=属性值,属性名=属性值,属性名=属性值…) 解析注解的步骤（本质获取注解属性值）： 获取注解定义的位置的对象 （Class、Method、Field） 获取指定的注解 getAnnotation(Class) 调用注解中的抽象方法获取配置的属性值 ","date":"2023-04-16","objectID":"/posts/java-custom-annotation/:2:0","tags":["java"],"title":"Java自定义注解","uri":"/posts/java-custom-annotation/"},{"categories":["java"],"content":"定义注解 定义一个注解：Book 包含属性：String value() 书名 包含属性：double price() 价格，默认值为 100 包含属性：String[] authors() 多位作者 代码实现 public @interface Book { // 书名 String value(); // 价格 double price() default 100; // 多位作者 String[] authors(); } ","date":"2023-04-16","objectID":"/posts/java-custom-annotation/:2:1","tags":["java"],"title":"Java自定义注解","uri":"/posts/java-custom-annotation/"},{"categories":["java"],"content":"使用注解 /* 使用注解 注意：如果属性有默认值，使用注解时可以不用赋值。如果没有则一定要赋值 */ public class DemoUseAnnotation { @Book(value = \"Java编程思想\", price = 100, authors = {\"Bruce Eckel\", \"Bruce Eckel2\"}) public void use() { } } 使用注意事项：如果属性有默认值，使用注解时可以不用赋值。如果没有则一定要赋值 特殊情况： 当注解中只有一个属性且名称是value，在使用注解时给value属性赋值可以直接给属性值，无论value是单值元素还是数组类型。 如果注解中除了value属性还有其他属性，且至少有一个属性没有默认值，则在使用注解给属性赋值时，value属性名不能省略。 元注解 默认情况下，注解可以用在任何地方，比如类，成员方法，构造方法，成员变量等地方。如果要限制注解的使用位置怎么办？元注解。 @Target @Retention @Target作用：指明此注解用在哪个位置，如果不写默认是任何地方都可以使用。 可选的参数值在枚举类ElemenetType中包括： TYPE： 用在类，接口上 FIELD：用在成员变量上 METHOD： 用在方法上 PARAMETER：用在参数上 CONSTRUCTOR：用在构造方法上 LOCAL_VARIABLE：用在局部变量上 @Retention作用：定义该注解的生命周期(有效范围) 可选的参数值在枚举类型RetentionPolicy中包括： SOURCE：注解只存在于Java源代码中，编译生成的字节码文件中就不存在了。 CLASS：注解存在于Java源代码、编译以后的字节码文件中，运行的时候内存中没有，默认值。 RUNTIME：注解存在于Java源代码中、编译以后的字节码文件中、运行时内存中，程序可以通过反射获取该注解。 注解解析 通过Java技术获取注解数据的过程则称为注解解析。 ","date":"2023-04-16","objectID":"/posts/java-custom-annotation/:2:2","tags":["java"],"title":"Java自定义注解","uri":"/posts/java-custom-annotation/"},{"categories":["java"],"content":"与注解解析相关的接口 Anontation：所有注解类型的公共接口，类似所有类的父类是Object。 AnnotatedElement：定义了与注解解析相关的方法，常用方法以下四个： default boolean isAnnotationPresent(Class\u003c? extends Annotation\u003e annotationClass) 判断当前对象是否有指定的注解，有则返回true，否则返回false。 \u003cT extends Annotation\u003e T getAnnotation(Class\u003cT\u003e annotationClass) 获得当前对象上指定的注解对象。 \u003cT extends Annotation\u003e T getAnnotation(Class\u003cT\u003e annotationClass) 获得当前对象及其从父类上继承的所有的注解对象。 Annotation[] getAnnotations() 获得当前对象上所有的注解对象，不包括父类的。 ","date":"2023-04-16","objectID":"/posts/java-custom-annotation/:3:0","tags":["java"],"title":"Java自定义注解","uri":"/posts/java-custom-annotation/"},{"categories":["java"],"content":"获取注解数据的原理 注解作用在那个成员上，就通过反射获得该成员的对象来得到它的注解。 如注解作用在方法上，就通过方法(Method)对象得到它的注解。 // 得到方法对象 Method method=clazz.getDeclaredMethod(\"方法名\"); // 根据注解名得到方法上的注解对象 Book book=method.getAnnotation(Book.class); 如注解作用在类上，就通过Class对象得到它的注解。 // 获得Class对象 Class c=类名.class; // 根据注解的Class获得使用在类上的注解对象 Book book=c.getAnnotation(Book.class); ","date":"2023-04-16","objectID":"/posts/java-custom-annotation/:4:0","tags":["java"],"title":"Java自定义注解","uri":"/posts/java-custom-annotation/"},{"categories":["java"],"content":"案例：使用反射获取注解的数据 ","date":"2023-04-16","objectID":"/posts/java-custom-annotation/:5:0","tags":["java"],"title":"Java自定义注解","uri":"/posts/java-custom-annotation/"},{"categories":["java"],"content":"需求说明 定义注解Book，要求如下： 包含属性：String value() 书名 包含属性：double price() 价格，默认值为 100 包含属性：String[] authors() 多位作者 限制注解使用的位置：类和成员方法上 指定注解的有效范围：RUNTIME 定义BookStore类，在类和成员方法上使用Book注解 定义DemoResolutionAnn测试类获取Book注解上的数据 ","date":"2023-04-16","objectID":"/posts/java-custom-annotation/:5:1","tags":["java"],"title":"Java自定义注解","uri":"/posts/java-custom-annotation/"},{"categories":["java"],"content":"代码实现 注解Book @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) public @interface Book { // 书名 String value(); // 价格 double price() default 100; // 作者 String[] authors(); } BookStore类 @Book(value = \"红楼梦\", authors = \"曹雪芹\", price = 998) public class BookStore { } ResolutionAnnotation类 /* 解析注解：取出BookStore类上的注解数据 */ public class DemoResolutionAnn { public static void main(String[] args) { //1.获取类的字节码对象 Class\u003cBookStore\u003e clz = BookStore.class; //2.判断类是否使用注解 boolean isAnn = clz.isAnnotationPresent(Book.class); //3.如果使用注解：则解析注解的属性 if (isAnn) { //获取字节码对象中的注解对象 Book book = clz.getAnnotation(Book.class); //获取Book注解的属性 String value = book.value(); System.out.println(\"value = \" + value); double price = book.price(); String[] authors = book.authors(); System.out.println(\"price = \" + price); System.out.println(\"authors = \" + Arrays.toString(authors)); } } } // 打印 // value = 红楼梦 // price = 998.0 // authors = [曹雪芹] 综合案例：模拟JUnit的@Test注解 案例分析 自定义注解@Test：功能类似@Test注解 添加元注解，保证自定义注解只能修饰方法，且在运行时可以获得。 编写调用类MyTestMainClass，使用main方法调用目标类，模拟Junit的运行，只要有@Test注释的方法都会运行。 编写测试类使用注解@Test，然后给方法（测试方法）加上 @Test注解 ","date":"2023-04-16","objectID":"/posts/java-custom-annotation/:5:2","tags":["java"],"title":"Java自定义注解","uri":"/posts/java-custom-annotation/"},{"categories":["java"],"content":"自定义注解@Test @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Test { } //定义注解执行器类 public class MyTestMainClass { public static void main(String[] args) throws IllegalAccessException, InstantiationException, InvocationTargetException { //获取类的字节码对象 Class\u003cDemoUseCustomTest\u003e clz = DemoUseCustomTest.class; //获取类的对象 DemoUseCustomTest obj = clz.newInstance(); //获取调用类的方法 Method[] methods = clz.getMethods(); //遍历获取方法的数组，反射执行方法 for (Method m : methods) { //如果是Test注解，则执行。否则不执行 if (m.isAnnotationPresent(Test.class)) { m.invoke(obj); } } } } // test01 test03 会打印 ","date":"2023-04-16","objectID":"/posts/java-custom-annotation/:6:0","tags":["java"],"title":"Java自定义注解","uri":"/posts/java-custom-annotation/"},{"categories":["java"],"content":"@Test注解使用 public class DemoUseCustomTest { @Test public void test01() { System.out.println(\"test01\"); } public void test02() { System.out.println(\"test02\"); } @Test public void test03() { System.out.println(\"test03\"); } } ","date":"2023-04-16","objectID":"/posts/java-custom-annotation/:7:0","tags":["java"],"title":"Java自定义注解","uri":"/posts/java-custom-annotation/"},{"categories":["java"],"content":"反射(Reflection) 允许运行中的Java 程序获取自身的信息，并且可以操作类或对象的内部属性。 反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。 ","date":"2023-04-15","objectID":"/posts/java-reflection/:0:0","tags":["java"],"title":"Java反射","uri":"/posts/java-reflection/"},{"categories":["java"],"content":"Java 反射主要提供以下功能 在运行时，判断任意一个对象所属的类； 在运行时，构造任意一个类的对象； 在运行时，判断任意一个类所具有的成员变量和方法（甚至可以调用private方法）； 在运行时，调用任意一个对象的方法 ","date":"2023-04-15","objectID":"/posts/java-reflection/:1:0","tags":["java"],"title":"Java反射","uri":"/posts/java-reflection/"},{"categories":["java"],"content":"获取类的Class对象的方式 获取class对象方式 作用 应用场景 对象.getClass() 通过对象的getClass()方法获取 多用于对象的获取字节码的方式 类名.class 通过类名的属性class获取 多用于参数的传递 Class.forName(“全类名”) 通过指定的字符串路径获取 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 ","date":"2023-04-15","objectID":"/posts/java-reflection/:2:0","tags":["java"],"title":"Java反射","uri":"/posts/java-reflection/"},{"categories":["java"],"content":"toString()方法 toString() return (isInterface() ? “interface \" : (isPrimitive() ? \"” : “class “))+ getName(); toGenericString() return a string describing this Class, including information about modifiers and type parameters 返回描述此类的字符串，包括有关修饰符和类型参数的信息。 ","date":"2023-04-15","objectID":"/posts/java-reflection/:3:0","tags":["java"],"title":"Java反射","uri":"/posts/java-reflection/"},{"categories":["java"],"content":"获取类的Class对象的 Class\u003c?\u003e forName(String className) 返回与给定字符串名称的类或接口相关联的类对象 public static void main(String[] args) throws Exception { //反射获取目标类的字节码对象，并执行其成员方法 Class\u003c?\u003e c1 = Class.forName(\"com.abc.clazz.Student\"); Object obj = c1.newInstance(); //反射获取有参数方法：Student的eat方法 Method eatMethod = c1.getMethod(\"eat\", String.class, double.class); //调用eat方法，传递实际参数 eatMethod.invoke(obj, \"西红柿炒鸡蛋\", 9.9); } Class\u003c?\u003e forName(String name, boolean initialize, ClassLoader loader) 使用给定的类加载器返回与给定字符串名称的类或接口相关联的类对象。如果参数loader为空，则通过引导类加载器加载该类。只有当initialize参数为true并且尚未被初始化时，该类才被初始化。 ","date":"2023-04-15","objectID":"/posts/java-reflection/:4:0","tags":["java"],"title":"Java反射","uri":"/posts/java-reflection/"},{"categories":["java"],"content":"Class类中与Constructor相关方法 Constructor[] getConstructors() 获取Class对象所表示的类的所有公共构造函数 Constructor\u003cT\u003e getConstructor(Class\u003c?\u003e... parameterTypes) 返回一个Constructor对象，该对象反映此Class对象所表示的类的指定公共构造函数.parameterTypes参数是一个Class对象的数组，用于按声明的顺序标识构造函数的形式参数类型 Constructor\u003cT\u003e getDeclaredConstructor(Class\u003c?\u003e... parameterTypes) Class类的getDeclaredConstructor()方法,可获取到类的私有构造器( 包括带有其他修饰符的构造器），但在使用private的构造器时，必须设置setAccessible()为true,才可以获取并操作该Constructor对象。 @Test void testName() throws Exception { HelloWorld world=null; String className=\"hello.HelloWorld\"; Constructor con=Class.forName(className).getDeclaredConstructor(); con.setAccessible(true); Object obj=con.newInstance(); world=(HelloWorld) obj; world.sayHello(); } ","date":"2023-04-15","objectID":"/posts/java-reflection/:5:0","tags":["java"],"title":"Java反射","uri":"/posts/java-reflection/"},{"categories":["java"],"content":"Constructor类中常用方法 T newInstance(Object ... initargs) 根据指定参数创建对象。 T newInstance() 空参构造方法创建对象。 void setAccessible(boolean flag) 设置是否允许访问私有构造方法 Class\u003c?\u003e[] getParameterTypes() 获取构造方法的所有参数类型 ","date":"2023-04-15","objectID":"/posts/java-reflection/:6:0","tags":["java"],"title":"Java反射","uri":"/posts/java-reflection/"},{"categories":["java"],"content":"Class类中与Method相关方法 Method[] getMethods() 获取所有的public修饰的成员方法，包括父类中。 Method getMethod(String name, Class\u003c?\u003e... parameterTypes) 根据方法名和参数类型获得一个方法对象，只能是获取public修饰的 Method[] getDeclaredMethods() 获取所有的成员方法，包括私有的，但是不包括父类中的方法 Method getDeclaredMethod(String name, Class\u003c?\u003e... parameterTypes) public class ClassDemo { public static void main(String[] args) { ClassDemo cls = new ClassDemo(); Class c = cls.getClass(); try { // parameter type is null Method m = c.getDeclaredMethod(\"show\", null); System.out.println(\"method = \" + m.toString()); // method Integer Class[] cArg = new Class[1]; cArg[0] = Integer.class; Method lMethod = c.getDeclaredMethod(\"showInteger\", cArg); System.out.println(\"method = \" + lMethod.toString()); } catch (NoSuchMethodException e) { System.out.println(e.toString()); } } private Integer show() { return 1; } public void showInteger(Integer i) { this.i = i; } public int i = 78655; } } // return: //method = private java.lang.Integer reflection.ClassDemo.show() //method = public void reflection.ClassDemo.showInteger(java.lang.Integer) ","date":"2023-04-15","objectID":"/posts/java-reflection/:7:0","tags":["java"],"title":"Java反射","uri":"/posts/java-reflection/"},{"categories":["java"],"content":"Method类中关键方法 Object invoke(Object obj, Object... args) 返回值Object，表示调用方法后，该方法的返回值 根据参数args调用对象obj的该成员方法 如果obj=null，则表示该方法是静态方法 void setAccessible(boolean flag) Class\u003c?\u003e[] getParameterTypes() 获取方法的所有参数类型 Class\u003c?\u003e getReturnType() 获取方法的返回值类型 String getName() 获取方法的名称 Annotation[][] getParameterAnnotations() 获取方法的参数注解 代码位置 java.lang.Object java.lang.Class java.lang.reflect.Constructor java.lang.reflect.Method java.lang.annotation.Annotation ","date":"2023-04-15","objectID":"/posts/java-reflection/:8:0","tags":["java"],"title":"Java反射","uri":"/posts/java-reflection/"},{"categories":["tools"],"content":"B站UP主江南琴师： ","date":"2023-03-25","objectID":"/posts/bilibili-jiangnanqinshi-home/:0:1","tags":["tools"],"title":"Bilibili天涯明月刀自制曲谱","uri":"/posts/bilibili-jiangnanqinshi-home/"},{"categories":["mysql"],"content":"一般处理并发问题会设计两种锁， 共享锁(shared lock)，S锁，也叫读锁(read lock)。 排他锁(exclusive lock)，X锁，也叫写锁(write lock)。 Mysql同样如此。 读锁互不阻塞（多个线程在同一时刻可以读取同一个资源，而不互相干扰）。而一个线程的写锁会会阻塞其他线程的写和读。 ","date":"2023-03-25","objectID":"/posts/mysql-lock/:0:0","tags":["mysql"],"title":"Mysql锁分析","uri":"/posts/mysql-lock/"},{"categories":["mysql"],"content":"1. 全局锁 全局锁是对整个数据库实例加锁，加锁后整个实例就处于只读状态。典型的使用场景是做全库的逻辑备份，对所有的表进行锁 定，从而获取一致性视图，保证数据的完整性。 加全局锁的命令为： flush tables with read lock; 释放全局锁的命令为： unlock tables; 或者断开加锁session的连接，自动释放全局锁。 对于InnoDB存储引擎，使用mysqldump备份时可以使用–single-transaction参数，利用mvcc提供一致性视图，而不使用全局锁，不会影响业务的正常运行。 # MyISAM 提交请求锁定所有数据库中的所有表，以保证数据的一致性，全局读锁【LBCC】 mysqldump -uroot -p --host=localhost --all-databases --lock-all-tables \u003e /root/db.sql # InnoDB 一致性视图【MVCC】 mysqldump -uroot -p --host=localhost --all-databases --single-transaction \u003e /root/db.sql ","date":"2023-03-25","objectID":"/posts/mysql-lock/:1:0","tags":["mysql"],"title":"Mysql锁分析","uri":"/posts/mysql-lock/"},{"categories":["mysql"],"content":"2. 表锁 ","date":"2023-03-25","objectID":"/posts/mysql-lock/:2:0","tags":["mysql"],"title":"Mysql锁分析","uri":"/posts/mysql-lock/"},{"categories":["mysql"],"content":"MySQL的表级锁有四种 表读锁（Table Read Lock） 表写锁（Table Write Lock） 元数据锁（meta data lock，MDL) 不需要显式指定 当对一个表做增删改查操作的时候，加 元数据 读锁；当要对表做结构变更操作的时候，加 元数据 写锁。 自增锁(AUTO-INC Locks) 涉及AUTO_INCREMENT列的事务性插入操作时产生 ","date":"2023-03-25","objectID":"/posts/mysql-lock/:2:1","tags":["mysql"],"title":"Mysql锁分析","uri":"/posts/mysql-lock/"},{"categories":["mysql"],"content":"表锁常用命令 # 查看表锁定状态 mysql\u003e show status like 'table%'; lock table t read; #为表t加读锁 lock table t write; #为表t加写锁 show open tables; #查看表锁情况 unlock tables; #删除表锁 【读阻塞写】 添加读锁后，当前Session插入或更新锁定的表会提示错误，其他Session插入或更新锁定表会一直等待 【写阻塞读】 添加写锁后，当前session对锁定表的查询+更新+插入操作都可执行，其他session对锁定表的查询被阻塞，需要等待锁被释放 ","date":"2023-03-25","objectID":"/posts/mysql-lock/:2:2","tags":["mysql"],"title":"Mysql锁分析","uri":"/posts/mysql-lock/"},{"categories":["mysql"],"content":"3. 行锁 MySQL的行级锁，是由存储引擎来实现的。InnoDB行锁是通过给索引上的索引项加锁来实现的 （这一点困扰了自己很长时间，一直以为是加在记录的那一行上） 因此只有通过索引条件检索的数据，InnoDB使用行级锁，否则将使用表锁。 InnoDB的行级锁，按锁定范围划分： 记录锁（Record Locks） 锁定索引中一条记录。 锁住的永远是索引，而非记录本身，即使该表上没有任何显示索引，那么innodb会在后台创建一个隐藏的聚簇索引索引，那么锁住的就是这个隐藏的聚簇索引索引。 间隙锁（Gap Locks） 锁住一个索引区间**（开区间，不包括双端端点）** 间隙锁可用于防止幻读，保证索引间隙不会被插入数据。在可重复读（RR）这个隔离级别下生效。 临键锁（Next-Key Locks） 相当于记录锁 + 间隙锁【左开右闭区间】 默认情况下，innodb使用临键锁来锁定记录，但在不同的场景中会退化 当查询的索引含有唯一属性的时候，临键锁会进行优化，将其降级为记录锁，即仅锁住索引本身，不是范围。 插入意向锁(Insert Intention Locks) 在 INSERT 操作之前设置的一种特殊的间隙锁。 插入意向锁不会阻止插入意向锁，但是插入意向锁会阻止其他间隙写锁（排他锁）、记录锁。 举个栗子：有两个事务分别尝试插入值为 60 和 70 的记录，每个事务使用插入意向锁锁定 11 和 99之间的间隙，但是这两个事务不会相互阻塞，因为行是不冲突的！这就是插入意向锁。 也就是说间隙锁锁住的范围太大，性能不好。而插入意向锁就是对间隙锁的优化。 意向锁（Intention Locks） 相当于存储引擎级别的表锁 意向锁和行锁可以共存，意向锁的主要作用是为了全表更新数据时的提升性能。否则在全表更新数据时，需要先检索该范是否某些记录上面有行锁。那么将是一件非常繁琐且耗时操作。 说白了，只需要判断一次即可知道某表有没数据行被锁定，提升性能 InnoDB的行级锁，按功能划分： 读锁：阻止其他事务加写锁，但不阻止其他事务加读锁。 写锁：阻止其他事务加读锁和写锁。 ","date":"2023-03-25","objectID":"/posts/mysql-lock/:3:0","tags":["mysql"],"title":"Mysql锁分析","uri":"/posts/mysql-lock/"},{"categories":["mysql"],"content":"如何加行级锁？ 对于UPDATE*、*DELETE和INSERT语句，InnoDB会自动给涉及数据集加写锁； 对于普通SELECT语句，InnoDB不会加任何锁 #添加读锁 select * from t1_simple where id = 4 lock in share mode; #添加写锁 select * from t1_simple where id = 4 for update; ","date":"2023-03-25","objectID":"/posts/mysql-lock/:3:1","tags":["mysql"],"title":"Mysql锁分析","uri":"/posts/mysql-lock/"},{"categories":["mysql"],"content":"加锁规则 主键索引 等值条件，命中，加记录锁 等值条件，未命中，加间隙锁 范围条件，命中，包含where条件的临键区间，加临键锁 范围条件，没有命中，加间隙锁 辅助索引 等值条件，命中，命中记录的辅助索引项 + 主键索引项加记录锁，辅助索引项两侧加间隙锁 等值条件，未命中，加间隙锁 范围条件，命中，包含where条件的临键区间加临键锁。命中记录的id索引项加记录锁 范围条件，没有命中，加间隙锁 ","date":"2023-03-25","objectID":"/posts/mysql-lock/:3:2","tags":["mysql"],"title":"Mysql锁分析","uri":"/posts/mysql-lock/"},{"categories":["mysql"],"content":"4. 讨论一条sql执行时加了什么锁。 delete from t1 where id = 10; # 假设数据表有两列，id和name 首先再次明确一个概念，Mysql的行锁是加在索引上的。 然后需要考虑一些前置条件 当前的数据库隔离级别 id列是否是主键 若不是主键，id列是否有索引 如果id列有二级索引，是唯一索引吗 当前是否存在id=10的数据 ","date":"2023-03-25","objectID":"/posts/mysql-lock/:4:0","tags":["mysql"],"title":"Mysql锁分析","uri":"/posts/mysql-lock/"},{"categories":["mysql"],"content":"分析 case 1 : id为主键 只需要将主键上id = 10的记录加上写锁即可。 case 2：id非主键，但是一个Unique的二级索引键值 假设name是主键 首先在辅助索引中找到符合条件的记录（通过id查找name），加写锁 然后拿着主键name去主键索引（聚簇索引）中找到记录，也加写锁 一共加锁2个 case 3：id有二级索引，但是非唯一索引 case3-1: 隔离级别RC情况下 由于id列非唯一，假设根据id能查到n条数据 同case2，辅助索引和主键索引上符合条件的记录都加写锁 一共加锁2*n个 case3-2: 隔离级别RR情况下 RR隔离级别，不允许存在幻读 同一个事务，连续做两次当前读 (例如：select * from t1 where id = 10 for update;)，那么这两次当前读返回的是完全相同的记录 (记录数量一致，记录本身也一致) **如何保证两次当前读返回一致的记录？**那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交。–\u003e间隙锁 首先，通过id索引定位到第一条满足查询条件的记录，加记录上的写锁，加GAP上的间隙锁，然后加主键聚簇索引上的记录写锁，然后返回； 然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录写锁，但是仍旧需要加间隙锁，最后返回结束。 和RC隔离级别相比，增加了在辅助索引上的间隙锁，间隙锁的个数取决于数据位置。一共加锁2*n+x个 case 4: id无索引 case4-1: 隔离级别RC情况下 由于id列上没有索引，因此只能走聚簇索引，进行全部扫描 首先，聚簇索引上所有的记录，都被加上了写锁 但是MySQL做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁/放锁动作不会省略。 case4-2: 隔离级别RR情况下 RR隔离级别，不允许存在幻读 首先，聚簇索引上的所有记录，都被加上了写锁。其次，聚簇索引每条记录间的间隙，也同时被加上了间隙锁。 假设表中有1千万数据，那么就是加1千万记录锁和1千万零1条间隙锁。 在这种情况下，这个表上，除了不加锁的快照度，其他任何加锁的并发SQL，均不能执行，不能更新，不能删除，不能插入，全表被锁死。（很严重了！） 同RC一样，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁/放锁动作不会省略。 case5: 串行化Serializable 隔离级别下 MVCC并发控制降级为LBCC 同case4-2 ","date":"2023-03-25","objectID":"/posts/mysql-lock/:4:1","tags":["mysql"],"title":"Mysql锁分析","uri":"/posts/mysql-lock/"},{"categories":["linux"],"content":"对于linux或者mac，bash是用户和系统交互的最基本的脚本环境。 而**zsh（Z shell）**是bash的一个替代品，他对于bash有了很多的优化，无论是使用命令，外观，体验，能够让用户更方便顺畅的使用Terminal。 ","date":"2022-05-25","objectID":"/posts/linux-environment-variables/:0:0","tags":["linux"],"title":"Linux环境变量","uri":"/posts/linux-environment-variables/"},{"categories":["linux"],"content":"Linux提供了修改和查看环境变量的命令： echo 显示某个环境变量值 echo $PATH export 设置一个新的环境变量 export HELLO=“hello” (可以无引号) env 显示所有环境变量 set 显示本地定义的shell变量 unset 清除环境变量 unset HELLO readonly 设置只读环境变量 readonly HELLO ","date":"2022-05-25","objectID":"/posts/linux-environment-variables/:0:1","tags":["linux"],"title":"Linux环境变量","uri":"/posts/linux-environment-variables/"},{"categories":["linux"],"content":"环境变量执行顺序 ","date":"2022-05-25","objectID":"/posts/linux-environment-variables/:0:2","tags":["linux"],"title":"Linux环境变量","uri":"/posts/linux-environment-variables/"},{"categories":["linux"],"content":"1. profile、 bashrc、.bash_profile、 .bashrc bash会在用户登录时，读取下列四个环境配置文件： 全局环境变量设置文件：/etc/profile、/etc/bashrc。用户环境变量设置文件：~/.bash_profile、~/.bashrc。 读取顺序：① /etc/profile、② ~/.bash_profile、③ ~/.bashrc、④ /etc/bashrc。 **① /etc/profile：此文件为系统的每个用户设置环境信息，系统中每个用户登录时都要执行这个脚本，如果系统管理员希望某个设置对所有用户都生效，可以写在这个脚本里，该文件也会从/etc/profile.d目录中的配置文件中搜集shell的设置。 ** ②**~/.bash_profile**：每个用户都可使用该文件设置专用于自己的shell信息，当用户登录时，该文件仅执行一次。默认情况下，他设置一些环境变量，执行用户的.bashrc文件。 ③~/.bashrc：该文件包含专用于自己的shell信息，当登录时以及每次打开新shell时，该文件被读取。 ④**/etc/bashrc**：为每一个运行bash shell的用户执行此文件，当bash shell被打开时，该文件被读取。 ","date":"2022-05-25","objectID":"/posts/linux-environment-variables/:1:0","tags":["linux"],"title":"Linux环境变量","uri":"/posts/linux-environment-variables/"},{"categories":["linux"],"content":"2 .bashrc和.bash_profile的区别 .bash_profile会用在登陆shell， .bashrc 使用在交互式非登陆 shell 。简单说来，它们的区别主要是.bash_profile是在你每次登录的时候执行的；.bashrc是在你新开了一个命令行窗口时执行的。 当通过控制台进行登录（输入用户名和密码）：在初始化命令行提示符的时候会执行.bash_profile 来配置你的shell环境。 但是如果已经登录到机器，在Gnome或者是KDE也开了一个新的终端窗口（xterm），这时，.bashrc会在窗口命令行提示符出现前被执行。当你在终端敲入/bin/bash时.bashrc也会在这个新的bash实例启动的时候执行。 ","date":"2022-05-25","objectID":"/posts/linux-environment-variables/:2:0","tags":["linux"],"title":"Linux环境变量","uri":"/posts/linux-environment-variables/"},{"categories":["linux"],"content":"3. 建议 大多数的时候你不想维护两个独立的配置文件，一个登录的一个非登录的shell。当你设置PATH时，你想在两个文件都适用。可以在.bash_profile中调用.bashrc，然后将PATH和其他通用的设置放到.bashrc中。要做到这几点，添加以下几行到.bash_profile中： if [ -f ~/.bashrc ]; then . ~/.bashrc fi 现在，当你从控制台登录机器的时候，.bashrc就会被执行。 ","date":"2022-05-25","objectID":"/posts/linux-environment-variables/:3:0","tags":["linux"],"title":"Linux环境变量","uri":"/posts/linux-environment-variables/"},{"categories":["linux"],"content":"PS环境变量 PS即是Prompt String,命令提示符的意思。在bash中一共有四个。分为表示为PS1,PS2,PS3,PS4。 PS1是用来控制默认提示符显示格式。 \\t显示时间为24小时格式，如HHMMSS \\T显示时间为12小时格式 \\A显示时间为24小时格式HHMM \\u当前用户的账号名称 \\vBASH的版本信息 \\w完整的工作目录名称 一个非常长的命令可以通过在末尾加\\使其分行显示。多行命令的默认提示符是\u003e。 我们可以通过修改PS2，将提示符修改为-\u003e。 PS3: shell脚本中使用select循环时的提示符。 PS4: 它是Linux/Unix下的一个用于控制脚本调试显示信息的环境变量。 ","date":"2022-05-25","objectID":"/posts/linux-environment-variables/:4:0","tags":["linux"],"title":"Linux环境变量","uri":"/posts/linux-environment-variables/"},{"categories":["books"],"content":" 这是2014年就知道的一本书了，曾经一位培训老师推荐的。德鲁克的经典，也让我对管理学有了初步认识。其中非常有启发的是两点。 ","date":"2022-02-26","objectID":"/posts/the-effective-manager/:0:0","tags":["books"],"title":"读《卓有成效的管理者》","uri":"/posts/the-effective-manager/"},{"categories":["books"],"content":"1.卓有成效是可以学会的 ","date":"2022-02-26","objectID":"/posts/the-effective-manager/:1:0","tags":["books"],"title":"读《卓有成效的管理者》","uri":"/posts/the-effective-manager/"},{"categories":["books"],"content":"4类非管理者本人所能控制的现实难题 1.不速之客 2.事项优先级标准的把握 3.让自身成果为组织所用 4.视野受组织内部限制 ","date":"2022-02-26","objectID":"/posts/the-effective-manager/:1:1","tags":["books"],"title":"读《卓有成效的管理者》","uri":"/posts/the-effective-manager/"},{"categories":["books"],"content":"管理者必须在思想上养成的习惯 1.知道自己的时间用在什么地方。由于自己所能控制的时间非常有限，要有系统地工作，来善用这有限的时间。 2.重视对外界的贡献。不要一开始就探究工作的技术和手段，首先自问：“别人期望我做出什么成果？” 3.善于利用长处，包括自己的长处、上司的长处、同事的长处和下属的长处。要善于抓住有利形势，做自己想做的事情。不要把工作建立在自己的短处上，也绝不去做自己做不了的事情。 4.要事第一。集中精力于少数重要的领域，在这少数重要的领域中，如果能有优秀的绩效就可以产生卓越的成果。 5.必须善于做有效的决策。需要正确的战略，而不是令人眼花缭乱的战术。 ","date":"2022-02-26","objectID":"/posts/the-effective-manager/:1:2","tags":["books"],"title":"读《卓有成效的管理者》","uri":"/posts/the-effective-manager/"},{"categories":["books"],"content":"2.掌握自己的时间 ","date":"2022-02-26","objectID":"/posts/the-effective-manager/:2:0","tags":["books"],"title":"读《卓有成效的管理者》","uri":"/posts/the-effective-manager/"},{"categories":["books"],"content":"时间对管理者的压力 在组织中的地位越高，组织对他的时间要求往往越大 每一位管理者的时间，都有很大部分是被浪费掉的。表面上看起来，每件事似乎都非办不可，实际上毫无意义。 与他人一起工作时，时间很重要。与他人只接触三两分钟，是不会产生什么结果的。如果你真想影响别人，至少需要一小时以上。如果你想和别人建立良好的人际关系，就需要更多的时间。 对体力工作者，我们可以说：“标准是每小时完成50件，而你只做了42件”。但是对一位知识工作者，我们却需要坐下来与他共同讨论应该做些什么，为什么该做，然后才能弄清楚他的工作做得怎么样，这就很浪费时间了。 知识工作者只能自己制定工作方向，所以他必须了解别人期望他做出的贡献是什么，原因是什么，对必须使用其工作成果的人的工作情况，他也要有足够的了解。因此，知识工作者需要资料，需要讨论，还需要指导他人，这都是极为费时的。而且。他不但需要占用他上级的时间，也同样需要占用他周围同事的时间。 知识工作者要想取得成果和绩效，就必须着眼于整个组织的成果和绩效。换句话说，他还得匀出时间来，将目光由自己的工作转到成果上；由他的专业转到外部世界，因为只有外部世界才有绩效可言 有人做决策很快，有人做决策很慢，但只要遇到人事问题，他们总是决定的很慢，而且常常需要经过多次考虑，才能最后定案。凡是有效的管理者，都知道他们如果想在人事方面做出最佳的决策，总得花费几个小时进行不间断的考虑 ","date":"2022-02-26","objectID":"/posts/the-effective-manager/:2:1","tags":["books"],"title":"读《卓有成效的管理者》","uri":"/posts/the-effective-manager/"},{"categories":["books"],"content":"如何诊断自己的时间 记录时间耗用的实际情形 做有系统的时间管理。先要将非生产性的和浪费时间的活动找出来，尽可能将这类活动从时间表上排除出去。 ","date":"2022-02-26","objectID":"/posts/the-effective-manager/:2:2","tags":["books"],"title":"读《卓有成效的管理者》","uri":"/posts/the-effective-manager/"},{"categories":["books"],"content":"消除浪费时间的活动 由于缺乏制度或远见而产生时间浪费。 人员过多，造成时间浪费。 组织不健全造成时间浪费（会议太多） 信息功能不健全或者信息表达方式不当 ","date":"2022-02-26","objectID":"/posts/the-effective-manager/:2:3","tags":["books"],"title":"读《卓有成效的管理者》","uri":"/posts/the-effective-manager/"},{"categories":["books"],"content":"统一安排可以自由支配的时间 一位管理者无论怎样无情地删掉浪费的部分，其自由时间仍不会太多。 高级主管真能自由运用的时间，大概只有1/4。就是说他只有1/4的时间能用在重大事务上，能用在有所贡献的事务上，能用在他应该做的事务上。 有效的管理者知道他必须集中他的自由时间。如果时间分割成许多段，等于没有时间。时间如果能集中，即使只有一个工作日的1/4，也足可办理几件大事。 “认识你自己”这句充满智慧的哲言，对我们一般人来说，真是太难理解了。可是，“认识你的时间”却是任何人只要肯做就能做到的，这是通向贡献和有效性之路。 ","date":"2022-02-26","objectID":"/posts/the-effective-manager/:2:4","tags":["books"],"title":"读《卓有成效的管理者》","uri":"/posts/the-effective-manager/"},{"categories":["books"],"content":" 作者：张维迎 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:0","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《序言》 理性人是追求自己的利益的。但人们所理解的利益本身是由理念构造的，也就是说，什么是我们的利益，依赖于我们拥有什么样的思想、什么样的信念。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:1","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《01 经济学中的利益和理念》 人们是通过观念来理解自己的利益的，而人的认识有限，观念可能发生错误，这样的话，他们就会做出对自己不利的决策。 人类的行为不仅仅是受利益的支配，也受观念的支配。也正因为这样，好多出于利益的行为经常打着观念的旗号。经济学家的任务就是通过自己的研究改变人们的观念，使人们能更好地认识到自己的根本利益之所在。 今天我们确实面临着这样的问题（思想是不自由的）。我们始终不应该忘记，人类观念的进步一定是从少数人开始的，如果不能对少数人的思想给与真正的宽容，我们的社会不可能有真正的进步。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:2","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《02无知与无耻》 “人祸”之所以产生，有两个基本原因：第一个是我们的无知，第二个是我们的无耻。 只有市场经济才可以避免由于多数人的无知和少数人的无耻相结合导致的人类灾难。 任何一种思想，无论是哲学的还是宗教的，无论创始人多么伟大，无论在创造时多么正确，一旦取得法定垄断地位，就会变成无知的助推器、无耻的保护神，就会滋生更多的无知和无耻，给人类带来灾难。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:3","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《03人类合作的制度基础》 人类合作的范围越宽、越广，人类的进步就越快。为了合作，人类创造了各种各样的制度，包括私有产权、法治、社会规范和道德。 人类为什么要政府？就是为了走出囚徒困境，更好地合作。但另一方面，政府存在之后，它很可能变成侵害自由、侵害人类安全、破坏合作的一种力量。 怎么约束政府？唯一有效的办法是把权力关在笼子里。这个笼子就是宪政和民主制度。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:4","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《04市场是最有效的合作制度》 市场和自由实际上是同一个东西，如果你坚持市场经济，那你就应该赞成人类的自由选择，所以我说，市场就是自由，自由就是市场。 计划经济下中国人都生活在“囚徒困境”当中，市场化导向的改革开放就是为了走出囚徒困境，促进人与人之间的合作。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:5","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《05市场与道德》 市场从不视图改变人的本性，拥护市场的人没有想过用市场改变人的本性。相反，正因为人的本性没有办法改变，我们才需要市场经济，也才有了市场经济。 宗教的逻辑是通过改变人的心来达到善的行为，市场的逻辑不改变人的心，而是规范人的行（行为），即以利人之行，实现利己之心。 市场经济需要道德基础，但这一道德只能在市场中实现和找到，也可以反过来说，道德需要建立在市场的基础上。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:6","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《06和谐社会的三个要素》 我认为和谐社会包括三个重要的要素：第一，是有一些绝大多数人都认可的核心价值观念；第二，要有一个与核心价值相一致的游戏规则，或者说行为规范；第三，要有社会组织形态的保证。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:7","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《07中国经济的奇迹来自市场化改革》 回顾改革开放三十年，我们取得的成就几乎都来自市场化的改革，我们存在的问题根本上源于市场化改革还不确定，政府拥有的权利还太大，企业家的作用还没有能够真正彻底地发挥出来。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:8","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《08从职权经济到产权经济》 任何社会，无论是什么样的所有制，权利都是个人的，行使权利的主体只能是个人，一个国家、一个企业不能行使权利，只有一个活生生的人，有灵魂、有思想的人，才能行使这个权利。 尽管在公有制下人们也在“竞争”，但属于破坏性的竞争，用“斗争”一词更恰当，就是怎么把别人拉下来然后自己上去。 私有制的竞争是创造财富的竞争，是给别人带来幸福和快乐的竞争，由此产生了很多新的发明创造和技术进步。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:9","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《09中国在全球化当中获得了什么》 全球化在今天是什么意思？就是利用全人类的智慧，不同地区、不同国家的人相互学习、相互合作。任何一个地方都是你中有我，我中有你，没有一个地方可以孤立进步。 历史证明，什么时候市场的逻辑居于主导地位，人类就会进步；什么时候抢到的逻辑占了上风，就会带来人类的倒退。 在全球化时代，如果我们不能够按照世界通行的游戏规则来行动，我们就不可能全面相守人类合作带来的好处。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:10","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《10未来经济增长靠企业家精神》 亚当·斯密在两百多年前就强调市场规模至关重要，市场规模带来分工，分工带来技术进步，技术进步带来经济增长。但所有这些背后靠什么？靠企业家精神。 过去三十年中国企业家做的是什么？主要是发现不均衡，或者说是“套利”。中国下一步增长的关键是中国企业家能否从套利行为转向真正的创新。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:11","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《11企业家精神依赖于法治环境和文化环境》 我所理解的一个国家、一个社会的经济成长过程，企业家在其中处于中心地位，无论是发现市场，创造产业，技术进步，还是把增加的收入变成新的市场，都离不开企业家的作用。 政府的作用在什么地方？就是为企业家发现市场、创造产业、革新技术提供一个良好的制度环境，特别是私有产权的有效保护和自由竞争。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:12","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《12从特权到权利》 我们离市场经济还有多远？大概还有三百年，至少还有两百年。因为我们的经济仍然是建立在特权的基础上，而不是建立在权利的基础上。 市场的基础是什么呢？我想就三点，第一是自由，第二是产权，第三是企业家精神。 如果公民不能够充分享有言论和行动、创业的自由，如果私有财产权利不能得到有效的法律保护和文化保护，如果企业家精神得不到有效的发挥，我们不可能建立真正的市场经济。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:13","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《13天理与王法》 任何人都不应该以“法律”为托词行不正当之事。当法律不符合天理时，当你不得不在良知和律法之间挣扎的时候，你应该选择站在天理的一边。 法治不等于律法之治。法治首先是“理治”（天理之治）。法律不符合天理，司法不讲良知，就不可能有真正的法治。“无法无天”不是一个好社会，“有法无天”也不是一个好社会。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:14","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《14建立市场经济需要落实宪法》 如果中国不进行真正的政治体制改革，不落实宪法、建设法治，靠单兵突进的经济改革无法走下去，不可能建立起真正的市场经济。 如果大部分人能积极行使宪法和法律赋予的权利，这个社会就有希望往好的方向发展。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:15","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《15宪法的生命在于实施》 我相信未来十年，只要我们真正落实了宪法，中国就向民主自由和法治社会迈进了一大步，中国的企业就会有更好的生存环境，市场的力量就可以更好地发挥作用，每个人也会生活地更有尊严。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:16","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《16未来三十年重点是政治体制改革》 中国历史有两次真正大的结果性变革，第一次大变革是从封建制到帝国制的改变，第二次大变革是从帝国制到民主社会，过去三十年和未来三十年，或许是中国两百年历史大变革最后的一幕。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:17","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《17语言腐败及其危害》 当一个人已经腐化而侮辱了他的思想的纯洁，从而宣扬他自己所不相信的东西，他已经准备犯其他任何的罪行。——托马斯·潘恩 左的东西之所以能流行，有市场，有人追随，一个重要的原因是左派人士善于语言腐败。 如果我们能真正执行宪法第35条，至少可以消除50%的语言腐败，如果我们能消除这50%危害最大的的语言腐败，就有希望消除80%的官员腐败。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:18","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《18既得利益者能否成为改革者》 许多成功的改革，甚至革命，都是既得利益者推动甚至领导的。如果既得利益者不能变成改革者，改革是没有希望的。 在一个大的历史变革当中，统治者最好有华盛顿的理念。如果没有华盛顿的理念，至少应该有华盛顿太太的危机感。如果都没有，那就麻烦了。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:19","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《19社会矛盾激化源自改革停滞》 前二十五年的改革积累的改革红利使得过去十年成为经济增长最好的十年；而过去十年改革的停滞乃至倒退，是导致我们社会越来越不和谐的主要原因。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:20","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《20什么决定中国的未来？》 两个东西最重要：第一个是理念、观念；第二个是领导力。所谓理念、观念，就是我们相信什么、不相信什么，我们认为什么样的体制、什么样的制度有助于我们国家的发展，有助于人民的幸福。所谓领导力，是指什么样的人在领导着我们，他们有什么样的担当，他们是不是有足够的智慧、足够的勇气、足够的责任心。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:21","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《21未来十年是改革的唯一窗口期》 中国未来三十年改革的大目标应该是，建立一个“自由、公正、法治、民主的社会”。这应该是中国共产党作为执政党的历史使命。 短期来看，变革期间，领导人的理念非常重要，但长期看，是普通大众的理念在决定着我们的未来。如果老百姓的理念变了，这个社会一定会变。问题只是以何种方式变而已。如果领导人的理念走在大众的前面，那就是改革；反之，如果领导人的理念落后于大众，那就可能是革命。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:22","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《22中国需要制度企业家》 我们今天面临着与一百多年前同样的问题，我们需要一个新的启蒙时代，这个时代应该到来，而且一定会来。 启蒙需要理论型制度企业家，需要用新的观点、新的理论、新的价值去说服社会，使我们这个社会能够有所改变。 中国也需要实践型制度企业家，也就是领导变革的政治家。要成为好的政治家，必须有两个基本素质：第一个是正确的理念，第二个是强的领导力，也就是远见卓识、愿景、使命感、责任心、激情、政治技能。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:23","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《23改革要从功利主义转向权利优先》 中国改革，无论我们思考问题还是制定政策，都必须从功利主义导向转向权利优先。 市场不仅仅是GDP增长的工具，市场是人类实现自我价值、追求卓越的一种途径。只要我们尊重了人的基本权利，给每个人平等的自由，市场经济自然就会到来。反 之，如果我们的体制和政策不尊重人的基本权利和自由，再多的改革措施都不可能建立起真正的市场经济制度。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:24","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["books"],"content":"《24没有思想市场就没有中国的未来》 所谓思想市场，就是学术、观点、言论、信仰的表达自由和它们之间的平等竞争。 社会的变革和人类的进步基本上都是在新的理念推动下出现的，没有理念的变化就没有制度和政策的改变，而没有思想市场，就很难有新的理念的出现和传播，从而整个社会就失去了变革的源泉。 ","date":"2022-02-10","objectID":"/posts/the-power-of-ideas/:0:25","tags":["books"],"title":"《理念的力量》摘抄","uri":"/posts/the-power-of-ideas/"},{"categories":["tools"],"content":"本地运行hugo命令 hugo server 或者 hugo server -D 加上-D参数，可以显示草稿状态的文章。 本地浏览器访问 http://localhost:1313/ 即可看到博客。 ","date":"2021-04-18","objectID":"/posts/write-blog-with-hugo/:0:1","tags":["tools"],"title":"使用hugo写博客","uri":"/posts/write-blog-with-hugo/"},{"categories":["tools"],"content":"写文章 通过下面命令新建文章，然后手动打开编辑该文件即可，每次保存文章，浏览器会自动重新渲染。 hugo new posts/MyBlog.md ","date":"2021-04-18","objectID":"/posts/write-blog-with-hugo/:0:2","tags":["tools"],"title":"使用hugo写博客","uri":"/posts/write-blog-with-hugo/"},{"categories":["tools"],"content":"发布博客 将需要发布的文章的内容里draft: false标识的值改为true，然后运行下面命令 hugo 会生成静态文件到public目录，最后将这些静态博客文件推送到github page或者自己的静态文件服务器上即可。 ","date":"2021-04-18","objectID":"/posts/write-blog-with-hugo/:0:3","tags":["tools"],"title":"使用hugo写博客","uri":"/posts/write-blog-with-hugo/"}]